// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vehicle.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "vehicle.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)

namespace vehicle {

void protobuf_ShutdownFile_vehicle_2eproto() {
  delete Point::default_instance_;
  delete Points::default_instance_;
  delete Box::default_instance_;
  delete Image::default_instance_;
  delete Plate::default_instance_;
  delete Gis::default_instance_;
  delete VehicleInfo::default_instance_;
  delete Nonmotor::default_instance_;
  delete Person::default_instance_;
  delete TrafficCondition::default_instance_;
  delete TrafficFlow::default_instance_;
  delete Anomaly::default_instance_;
  delete VehicleCapture::default_instance_;
  delete SmartMessage::default_instance_;
  delete FrameMessage::default_instance_;
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
void protobuf_AddDesc_vehicle_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#else
void protobuf_AddDesc_vehicle_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_vehicle_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

#endif
  Point::default_instance_ = new Point();
  Points::default_instance_ = new Points();
  Box::default_instance_ = new Box();
  Image::default_instance_ = new Image();
  Plate::default_instance_ = new Plate();
  Gis::default_instance_ = new Gis();
  VehicleInfo::default_instance_ = new VehicleInfo();
  Nonmotor::default_instance_ = new Nonmotor();
  Person::default_instance_ = new Person();
  TrafficCondition::default_instance_ = new TrafficCondition();
  TrafficFlow::default_instance_ = new TrafficFlow();
  Anomaly::default_instance_ = new Anomaly();
  VehicleCapture::default_instance_ = new VehicleCapture();
  SmartMessage::default_instance_ = new SmartMessage();
  FrameMessage::default_instance_ = new FrameMessage();
  Point::default_instance_->InitAsDefaultInstance();
  Points::default_instance_->InitAsDefaultInstance();
  Box::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  Plate::default_instance_->InitAsDefaultInstance();
  Gis::default_instance_->InitAsDefaultInstance();
  VehicleInfo::default_instance_->InitAsDefaultInstance();
  Nonmotor::default_instance_->InitAsDefaultInstance();
  Person::default_instance_->InitAsDefaultInstance();
  TrafficCondition::default_instance_->InitAsDefaultInstance();
  TrafficFlow::default_instance_->InitAsDefaultInstance();
  Anomaly::default_instance_->InitAsDefaultInstance();
  VehicleCapture::default_instance_->InitAsDefaultInstance();
  SmartMessage::default_instance_->InitAsDefaultInstance();
  FrameMessage::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_vehicle_2eproto);
}

#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_vehicle_2eproto_once_);
void protobuf_AddDesc_vehicle_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_vehicle_2eproto_once_,
                 &protobuf_AddDesc_vehicle_2eproto_impl);
}
#else
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_vehicle_2eproto {
  StaticDescriptorInitializer_vehicle_2eproto() {
    protobuf_AddDesc_vehicle_2eproto();
  }
} static_descriptor_initializer_vehicle_2eproto_;
#endif

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Point::kXFieldNumber;
const int Point::kYFieldNumber;
const int Point::kScoreFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Point::Point()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Point)
}

void Point::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Point::Point(const Point& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Point)
}

void Point::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  score_ = 0;
}

Point::~Point() {
  // @@protoc_insertion_point(destructor:vehicle.Point)
  SharedDtor();
}

void Point::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Point::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Point& Point::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Point* Point::default_instance_ = NULL;

Point* Point::New(::google::protobuf::Arena* arena) const {
  Point* n = new Point;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Point::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Point)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Point, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Point*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, score_);

#undef ZR_HELPER_
#undef ZR_

}

bool Point::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Point)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // optional float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_score;
        break;
      }

      // optional float score = 3;
      case 3: {
        if (tag == 29) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &score_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Point)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Point)
  return false;
#undef DO_
}

void Point::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Point)
  // optional float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // optional float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // optional float score = 3;
  if (this->score() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->score(), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Point)
}

int Point::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Point)
  int total_size = 0;

  // optional float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // optional float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // optional float score = 3;
  if (this->score() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Point::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Point*>(&from));
}

void Point::MergeFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Point)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.score() != 0) {
    set_score(from.score());
  }
}

void Point::CopyFrom(const Point& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Point)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Point::IsInitialized() const {

  return true;
}

void Point::Swap(Point* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Point::InternalSwap(Point* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(score_, other->score_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Point::GetTypeName() const {
  return "vehicle.Point";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Point

// optional float x = 1;
void Point::clear_x() {
  x_ = 0;
}
 float Point::x() const {
  // @@protoc_insertion_point(field_get:vehicle.Point.x)
  return x_;
}
 void Point::set_x(float value) {

  x_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Point.x)
}

// optional float y = 2;
void Point::clear_y() {
  y_ = 0;
}
 float Point::y() const {
  // @@protoc_insertion_point(field_get:vehicle.Point.y)
  return y_;
}
 void Point::set_y(float value) {

  y_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Point.y)
}

// optional float score = 3;
void Point::clear_score() {
  score_ = 0;
}
 float Point::score() const {
  // @@protoc_insertion_point(field_get:vehicle.Point.score)
  return score_;
}
 void Point::set_score(float value) {

  score_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Point.score)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Points::kTypeFieldNumber;
const int Points::kPointsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Points::Points()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Points)
}

void Points::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Points::Points(const Points& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Points)
}

void Points::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Points::~Points() {
  // @@protoc_insertion_point(destructor:vehicle.Points)
  SharedDtor();
}

void Points::SharedDtor() {
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Points::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Points& Points::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Points* Points::default_instance_ = NULL;

Points* Points::New(::google::protobuf::Arena* arena) const {
  Points* n = new Points;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Points::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Points)
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  points_.Clear();
}

bool Points::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Points)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vehicle.Points.type"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_points;
        break;
      }

      // repeated .vehicle.Point points = 2;
      case 2: {
        if (tag == 18) {
         parse_points:
          DO_(input->IncrementRecursionDepth());
         parse_loop_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_points;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Points)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Points)
  return false;
#undef DO_
}

void Points::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Points)
  // optional string type = 1;
  if (this->type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vehicle.Points.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->type(), output);
  }

  // repeated .vehicle.Point points = 2;
  for (unsigned int i = 0, n = this->points_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->points(i), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Points)
}

int Points::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Points)
  int total_size = 0;

  // optional string type = 1;
  if (this->type().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());
  }

  // repeated .vehicle.Point points = 2;
  total_size += 1 * this->points_size();
  for (int i = 0; i < this->points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->points(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Points::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Points*>(&from));
}

void Points::MergeFrom(const Points& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Points)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  points_.MergeFrom(from.points_);
  if (from.type().size() > 0) {

    type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
  }
}

void Points::CopyFrom(const Points& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Points)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Points::IsInitialized() const {

  return true;
}

void Points::Swap(Points* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Points::InternalSwap(Points* other) {
  type_.Swap(&other->type_);
  points_.UnsafeArenaSwap(&other->points_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Points::GetTypeName() const {
  return "vehicle.Points";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Points

// optional string type = 1;
void Points::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Points::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Points.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Points::set_type(const ::std::string& value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Points.type)
}
 void Points::set_type(const char* value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Points.type)
}
 void Points::set_type(const char* value, size_t size) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Points.type)
}
 ::std::string* Points::mutable_type() {

  // @@protoc_insertion_point(field_mutable:vehicle.Points.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Points::release_type() {
  // @@protoc_insertion_point(field_release:vehicle.Points.type)

  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Points::set_allocated_type(::std::string* type) {
  if (type != NULL) {

  } else {

  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Points.type)
}

// repeated .vehicle.Point points = 2;
int Points::points_size() const {
  return points_.size();
}
void Points::clear_points() {
  points_.Clear();
}
const ::vehicle::Point& Points::points(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.Points.points)
  return points_.Get(index);
}
::vehicle::Point* Points::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.Points.points)
  return points_.Mutable(index);
}
::vehicle::Point* Points::add_points() {
  // @@protoc_insertion_point(field_add:vehicle.Points.points)
  return points_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::Point >*
Points::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.Points.points)
  return &points_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::Point >&
Points::points() const {
  // @@protoc_insertion_point(field_list:vehicle.Points.points)
  return points_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Box::kTypeFieldNumber;
const int Box::kTopLeftFieldNumber;
const int Box::kBottomRightFieldNumber;
const int Box::kScoreFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Box::Box()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Box)
}

void Box::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  top_left_ = const_cast< ::vehicle::Point*>(
      ::vehicle::Point::internal_default_instance());
#else
  top_left_ = const_cast< ::vehicle::Point*>(&::vehicle::Point::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  bottom_right_ = const_cast< ::vehicle::Point*>(
      ::vehicle::Point::internal_default_instance());
#else
  bottom_right_ = const_cast< ::vehicle::Point*>(&::vehicle::Point::default_instance());
#endif
}

Box::Box(const Box& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Box)
}

void Box::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  top_left_ = NULL;
  bottom_right_ = NULL;
  score_ = 0;
}

Box::~Box() {
  // @@protoc_insertion_point(destructor:vehicle.Box)
  SharedDtor();
}

void Box::SharedDtor() {
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete top_left_;
    delete bottom_right_;
  }
}

void Box::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Box& Box::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Box* Box::default_instance_ = NULL;

Box* Box::New(::google::protobuf::Arena* arena) const {
  Box* n = new Box;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Box::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Box)
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && top_left_ != NULL) delete top_left_;
  top_left_ = NULL;
  if (GetArenaNoVirtual() == NULL && bottom_right_ != NULL) delete bottom_right_;
  bottom_right_ = NULL;
  score_ = 0;
}

bool Box::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Box)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string type = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vehicle.Box.type"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_top_left;
        break;
      }

      // optional .vehicle.Point top_left = 2;
      case 2: {
        if (tag == 18) {
         parse_top_left:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_top_left()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_bottom_right;
        break;
      }

      // optional .vehicle.Point bottom_right = 3;
      case 3: {
        if (tag == 26) {
         parse_bottom_right:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bottom_right()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_score;
        break;
      }

      // optional float score = 4;
      case 4: {
        if (tag == 37) {
         parse_score:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &score_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Box)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Box)
  return false;
#undef DO_
}

void Box::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Box)
  // optional string type = 1;
  if (this->type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vehicle.Box.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->type(), output);
  }

  // optional .vehicle.Point top_left = 2;
  if (this->has_top_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->top_left_, output);
  }

  // optional .vehicle.Point bottom_right = 3;
  if (this->has_bottom_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->bottom_right_, output);
  }

  // optional float score = 4;
  if (this->score() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->score(), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Box)
}

int Box::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Box)
  int total_size = 0;

  // optional string type = 1;
  if (this->type().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());
  }

  // optional .vehicle.Point top_left = 2;
  if (this->has_top_left()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->top_left_);
  }

  // optional .vehicle.Point bottom_right = 3;
  if (this->has_bottom_right()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->bottom_right_);
  }

  // optional float score = 4;
  if (this->score() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Box::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Box*>(&from));
}

void Box::MergeFrom(const Box& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Box)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.type().size() > 0) {

    type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
  }
  if (from.has_top_left()) {
    mutable_top_left()->::vehicle::Point::MergeFrom(from.top_left());
  }
  if (from.has_bottom_right()) {
    mutable_bottom_right()->::vehicle::Point::MergeFrom(from.bottom_right());
  }
  if (from.score() != 0) {
    set_score(from.score());
  }
}

void Box::CopyFrom(const Box& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Box)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Box::IsInitialized() const {

  return true;
}

void Box::Swap(Box* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Box::InternalSwap(Box* other) {
  type_.Swap(&other->type_);
  std::swap(top_left_, other->top_left_);
  std::swap(bottom_right_, other->bottom_right_);
  std::swap(score_, other->score_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Box::GetTypeName() const {
  return "vehicle.Box";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Box

// optional string type = 1;
void Box::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Box::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Box::set_type(const ::std::string& value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Box.type)
}
 void Box::set_type(const char* value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Box.type)
}
 void Box::set_type(const char* value, size_t size) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Box.type)
}
 ::std::string* Box::mutable_type() {

  // @@protoc_insertion_point(field_mutable:vehicle.Box.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Box::release_type() {
  // @@protoc_insertion_point(field_release:vehicle.Box.type)

  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Box::set_allocated_type(::std::string* type) {
  if (type != NULL) {

  } else {

  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Box.type)
}

// optional .vehicle.Point top_left = 2;
bool Box::has_top_left() const {
  return !_is_default_instance_ && top_left_ != NULL;
}
void Box::clear_top_left() {
  if (GetArenaNoVirtual() == NULL && top_left_ != NULL) delete top_left_;
  top_left_ = NULL;
}
const ::vehicle::Point& Box::top_left() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.top_left)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return top_left_ != NULL ? *top_left_ : *default_instance().top_left_;
#else
  return top_left_ != NULL ? *top_left_ : *default_instance_->top_left_;
#endif
}
::vehicle::Point* Box::mutable_top_left() {

  if (top_left_ == NULL) {
    top_left_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Box.top_left)
  return top_left_;
}
::vehicle::Point* Box::release_top_left() {
  // @@protoc_insertion_point(field_release:vehicle.Box.top_left)

  ::vehicle::Point* temp = top_left_;
  top_left_ = NULL;
  return temp;
}
void Box::set_allocated_top_left(::vehicle::Point* top_left) {
  delete top_left_;
  top_left_ = top_left;
  if (top_left) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Box.top_left)
}

// optional .vehicle.Point bottom_right = 3;
bool Box::has_bottom_right() const {
  return !_is_default_instance_ && bottom_right_ != NULL;
}
void Box::clear_bottom_right() {
  if (GetArenaNoVirtual() == NULL && bottom_right_ != NULL) delete bottom_right_;
  bottom_right_ = NULL;
}
const ::vehicle::Point& Box::bottom_right() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.bottom_right)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bottom_right_ != NULL ? *bottom_right_ : *default_instance().bottom_right_;
#else
  return bottom_right_ != NULL ? *bottom_right_ : *default_instance_->bottom_right_;
#endif
}
::vehicle::Point* Box::mutable_bottom_right() {

  if (bottom_right_ == NULL) {
    bottom_right_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Box.bottom_right)
  return bottom_right_;
}
::vehicle::Point* Box::release_bottom_right() {
  // @@protoc_insertion_point(field_release:vehicle.Box.bottom_right)

  ::vehicle::Point* temp = bottom_right_;
  bottom_right_ = NULL;
  return temp;
}
void Box::set_allocated_bottom_right(::vehicle::Point* bottom_right) {
  delete bottom_right_;
  bottom_right_ = bottom_right;
  if (bottom_right) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Box.bottom_right)
}

// optional float score = 4;
void Box::clear_score() {
  score_ = 0;
}
 float Box::score() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.score)
  return score_;
}
 void Box::set_score(float value) {

  score_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Box.score)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image::kBufFieldNumber;
const int Image::kTypeFieldNumber;
const int Image::kWidthFieldNumber;
const int Image::kHeightFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image::Image()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Image)
}

void Image::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Image::Image(const Image& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Image)
}

void Image::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  buf_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  width_ = 0u;
  height_ = 0u;
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:vehicle.Image)
  SharedDtor();
}

void Image::SharedDtor() {
  buf_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Image& Image::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New(::google::protobuf::Arena* arena) const {
  Image* n = new Image;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Image)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Image, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Image*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(width_, height_);
  buf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bytes buf = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_buf()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_type;
        break;
      }

      // optional string type = 2;
      case 2: {
        if (tag == 18) {
         parse_type:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_type()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->type().data(), this->type().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "vehicle.Image.type"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_width;
        break;
      }

      // optional uint32 width = 3;
      case 3: {
        if (tag == 24) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &width_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_height;
        break;
      }

      // optional uint32 height = 4;
      case 4: {
        if (tag == 32) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &height_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Image)
  // optional bytes buf = 1;
  if (this->buf().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->buf(), output);
  }

  // optional string type = 2;
  if (this->type().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->type().data(), this->type().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "vehicle.Image.type");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->type(), output);
  }

  // optional uint32 width = 3;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->width(), output);
  }

  // optional uint32 height = 4;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->height(), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Image)
}

int Image::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Image)
  int total_size = 0;

  // optional bytes buf = 1;
  if (this->buf().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->buf());
  }

  // optional string type = 2;
  if (this->type().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->type());
  }

  // optional uint32 width = 3;
  if (this->width() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->width());
  }

  // optional uint32 height = 4;
  if (this->height() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->height());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Image*>(&from));
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.buf().size() > 0) {

    buf_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.buf_);
  }
  if (from.type().size() > 0) {

    type_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.type_);
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {

  return true;
}

void Image::Swap(Image* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image::InternalSwap(Image* other) {
  buf_.Swap(&other->buf_);
  type_.Swap(&other->type_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Image::GetTypeName() const {
  return "vehicle.Image";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Image

// optional bytes buf = 1;
void Image::clear_buf() {
  buf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Image::buf() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.buf)
  return buf_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_buf(const ::std::string& value) {

  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Image.buf)
}
 void Image::set_buf(const char* value) {

  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Image.buf)
}
 void Image::set_buf(const void* value, size_t size) {

  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Image.buf)
}
 ::std::string* Image::mutable_buf() {

  // @@protoc_insertion_point(field_mutable:vehicle.Image.buf)
  return buf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image::release_buf() {
  // @@protoc_insertion_point(field_release:vehicle.Image.buf)

  return buf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_allocated_buf(::std::string* buf) {
  if (buf != NULL) {

  } else {

  }
  buf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buf);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Image.buf)
}

// optional string type = 2;
void Image::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Image::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_type(const ::std::string& value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Image.type)
}
 void Image::set_type(const char* value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Image.type)
}
 void Image::set_type(const char* value, size_t size) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Image.type)
}
 ::std::string* Image::mutable_type() {

  // @@protoc_insertion_point(field_mutable:vehicle.Image.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image::release_type() {
  // @@protoc_insertion_point(field_release:vehicle.Image.type)

  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image::set_allocated_type(::std::string* type) {
  if (type != NULL) {

  } else {

  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Image.type)
}

// optional uint32 width = 3;
void Image::clear_width() {
  width_ = 0u;
}
 ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.width)
  return width_;
}
 void Image::set_width(::google::protobuf::uint32 value) {

  width_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Image.width)
}

// optional uint32 height = 4;
void Image::clear_height() {
  height_ = 0u;
}
 ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.height)
  return height_;
}
 void Image::set_height(::google::protobuf::uint32 value) {

  height_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Image.height)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Plate::kBoxFieldNumber;
const int Plate::kIsDoublePlateFieldNumber;
const int Plate::kPointsFieldNumber;
const int Plate::kPlateNumFieldNumber;
const int Plate::kColorFieldNumber;
const int Plate::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Plate::Plate()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Plate)
}

void Plate::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  box_ = const_cast< ::vehicle::Box*>(
      ::vehicle::Box::internal_default_instance());
#else
  box_ = const_cast< ::vehicle::Box*>(&::vehicle::Box::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  points_ = const_cast< ::vehicle::Points*>(
      ::vehicle::Points::internal_default_instance());
#else
  points_ = const_cast< ::vehicle::Points*>(&::vehicle::Points::default_instance());
#endif
}

Plate::Plate(const Plate& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Plate)
}

void Plate::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  box_ = NULL;
  is_double_plate_ = false;
  points_ = NULL;
  plate_num_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  color_ = 0;
  type_ = 0;
}

Plate::~Plate() {
  // @@protoc_insertion_point(destructor:vehicle.Plate)
  SharedDtor();
}

void Plate::SharedDtor() {
  plate_num_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete box_;
    delete points_;
  }
}

void Plate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Plate& Plate::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Plate* Plate::default_instance_ = NULL;

Plate* Plate::New(::google::protobuf::Arena* arena) const {
  Plate* n = new Plate;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Plate::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Plate)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Plate, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Plate*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(is_double_plate_, color_);
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
  plate_num_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;

#undef ZR_HELPER_
#undef ZR_

}

bool Plate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Plate)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .vehicle.Box box = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_is_double_plate;
        break;
      }

      // optional bool is_double_plate = 2;
      case 2: {
        if (tag == 16) {
         parse_is_double_plate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_double_plate_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_points;
        break;
      }

      // optional .vehicle.Points points = 3;
      case 3: {
        if (tag == 26) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_plate_num;
        break;
      }

      // optional bytes plate_num = 4;
      case 4: {
        if (tag == 34) {
         parse_plate_num:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_plate_num()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_color;
        break;
      }

      // optional int32 color = 5;
      case 5: {
        if (tag == 40) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &color_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_type;
        break;
      }

      // optional int32 type = 6;
      case 6: {
        if (tag == 48) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Plate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Plate)
  return false;
#undef DO_
}

void Plate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Plate)
  // optional .vehicle.Box box = 1;
  if (this->has_box()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, *this->box_, output);
  }

  // optional bool is_double_plate = 2;
  if (this->is_double_plate() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->is_double_plate(), output);
  }

  // optional .vehicle.Points points = 3;
  if (this->has_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->points_, output);
  }

  // optional bytes plate_num = 4;
  if (this->plate_num().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->plate_num(), output);
  }

  // optional int32 color = 5;
  if (this->color() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->color(), output);
  }

  // optional int32 type = 6;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->type(), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Plate)
}

int Plate::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Plate)
  int total_size = 0;

  // optional .vehicle.Box box = 1;
  if (this->has_box()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->box_);
  }

  // optional bool is_double_plate = 2;
  if (this->is_double_plate() != 0) {
    total_size += 1 + 1;
  }

  // optional .vehicle.Points points = 3;
  if (this->has_points()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->points_);
  }

  // optional bytes plate_num = 4;
  if (this->plate_num().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->plate_num());
  }

  // optional int32 color = 5;
  if (this->color() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->color());
  }

  // optional int32 type = 6;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->type());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Plate::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Plate*>(&from));
}

void Plate::MergeFrom(const Plate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Plate)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.has_box()) {
    mutable_box()->::vehicle::Box::MergeFrom(from.box());
  }
  if (from.is_double_plate() != 0) {
    set_is_double_plate(from.is_double_plate());
  }
  if (from.has_points()) {
    mutable_points()->::vehicle::Points::MergeFrom(from.points());
  }
  if (from.plate_num().size() > 0) {

    plate_num_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.plate_num_);
  }
  if (from.color() != 0) {
    set_color(from.color());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void Plate::CopyFrom(const Plate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Plate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Plate::IsInitialized() const {

  return true;
}

void Plate::Swap(Plate* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Plate::InternalSwap(Plate* other) {
  std::swap(box_, other->box_);
  std::swap(is_double_plate_, other->is_double_plate_);
  std::swap(points_, other->points_);
  plate_num_.Swap(&other->plate_num_);
  std::swap(color_, other->color_);
  std::swap(type_, other->type_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Plate::GetTypeName() const {
  return "vehicle.Plate";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Plate

// optional .vehicle.Box box = 1;
bool Plate::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
void Plate::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
const ::vehicle::Box& Plate::box() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
::vehicle::Box* Plate::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Plate.box)
  return box_;
}
::vehicle::Box* Plate::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.Plate.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
void Plate::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Plate.box)
}

// optional bool is_double_plate = 2;
void Plate::clear_is_double_plate() {
  is_double_plate_ = false;
}
 bool Plate::is_double_plate() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.is_double_plate)
  return is_double_plate_;
}
 void Plate::set_is_double_plate(bool value) {

  is_double_plate_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Plate.is_double_plate)
}

// optional .vehicle.Points points = 3;
bool Plate::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
void Plate::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
const ::vehicle::Points& Plate::points() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
::vehicle::Points* Plate::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Plate.points)
  return points_;
}
::vehicle::Points* Plate::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.Plate.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
void Plate::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Plate.points)
}

// optional bytes plate_num = 4;
void Plate::clear_plate_num() {
  plate_num_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Plate::plate_num() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.plate_num)
  return plate_num_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Plate::set_plate_num(const ::std::string& value) {

  plate_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Plate.plate_num)
}
 void Plate::set_plate_num(const char* value) {

  plate_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Plate.plate_num)
}
 void Plate::set_plate_num(const void* value, size_t size) {

  plate_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Plate.plate_num)
}
 ::std::string* Plate::mutable_plate_num() {

  // @@protoc_insertion_point(field_mutable:vehicle.Plate.plate_num)
  return plate_num_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Plate::release_plate_num() {
  // @@protoc_insertion_point(field_release:vehicle.Plate.plate_num)

  return plate_num_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Plate::set_allocated_plate_num(::std::string* plate_num) {
  if (plate_num != NULL) {

  } else {

  }
  plate_num_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plate_num);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Plate.plate_num)
}

// optional int32 color = 5;
void Plate::clear_color() {
  color_ = 0;
}
 ::google::protobuf::int32 Plate::color() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.color)
  return color_;
}
 void Plate::set_color(::google::protobuf::int32 value) {

  color_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Plate.color)
}

// optional int32 type = 6;
void Plate::clear_type() {
  type_ = 0;
}
 ::google::protobuf::int32 Plate::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.type)
  return type_;
}
 void Plate::set_type(::google::protobuf::int32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Plate.type)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Gis::kLongitudeFieldNumber;
const int Gis::kLatitudeFieldNumber;
const int Gis::kWidthFieldNumber;
const int Gis::kHeightFieldNumber;
const int Gis::kOrientationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Gis::Gis()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Gis)
}

void Gis::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Gis::Gis(const Gis& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Gis)
}

void Gis::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  longitude_ = 0;
  latitude_ = 0;
  width_ = 0;
  height_ = 0;
  orientation_ = 0;
}

Gis::~Gis() {
  // @@protoc_insertion_point(destructor:vehicle.Gis)
  SharedDtor();
}

void Gis::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Gis::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Gis& Gis::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Gis* Gis::default_instance_ = NULL;

Gis* Gis::New(::google::protobuf::Arena* arena) const {
  Gis* n = new Gis;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Gis::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Gis)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Gis, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Gis*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(longitude_, orientation_);

#undef ZR_HELPER_
#undef ZR_

}

bool Gis::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Gis)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float longitude = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &longitude_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_latitude;
        break;
      }

      // optional float latitude = 2;
      case 2: {
        if (tag == 21) {
         parse_latitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &latitude_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_width;
        break;
      }

      // optional float width = 3;
      case 3: {
        if (tag == 29) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &width_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_height;
        break;
      }

      // optional float height = 4;
      case 4: {
        if (tag == 37) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_orientation;
        break;
      }

      // optional float orientation = 5;
      case 5: {
        if (tag == 45) {
         parse_orientation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &orientation_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Gis)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Gis)
  return false;
#undef DO_
}

void Gis::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Gis)
  // optional float longitude = 1;
  if (this->longitude() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->longitude(), output);
  }

  // optional float latitude = 2;
  if (this->latitude() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->latitude(), output);
  }

  // optional float width = 3;
  if (this->width() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->width(), output);
  }

  // optional float height = 4;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->height(), output);
  }

  // optional float orientation = 5;
  if (this->orientation() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->orientation(), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Gis)
}

int Gis::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Gis)
  int total_size = 0;

  // optional float longitude = 1;
  if (this->longitude() != 0) {
    total_size += 1 + 4;
  }

  // optional float latitude = 2;
  if (this->latitude() != 0) {
    total_size += 1 + 4;
  }

  // optional float width = 3;
  if (this->width() != 0) {
    total_size += 1 + 4;
  }

  // optional float height = 4;
  if (this->height() != 0) {
    total_size += 1 + 4;
  }

  // optional float orientation = 5;
  if (this->orientation() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Gis::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Gis*>(&from));
}

void Gis::MergeFrom(const Gis& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Gis)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.longitude() != 0) {
    set_longitude(from.longitude());
  }
  if (from.latitude() != 0) {
    set_latitude(from.latitude());
  }
  if (from.width() != 0) {
    set_width(from.width());
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.orientation() != 0) {
    set_orientation(from.orientation());
  }
}

void Gis::CopyFrom(const Gis& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Gis)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Gis::IsInitialized() const {

  return true;
}

void Gis::Swap(Gis* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Gis::InternalSwap(Gis* other) {
  std::swap(longitude_, other->longitude_);
  std::swap(latitude_, other->latitude_);
  std::swap(width_, other->width_);
  std::swap(height_, other->height_);
  std::swap(orientation_, other->orientation_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Gis::GetTypeName() const {
  return "vehicle.Gis";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Gis

// optional float longitude = 1;
void Gis::clear_longitude() {
  longitude_ = 0;
}
 float Gis::longitude() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.longitude)
  return longitude_;
}
 void Gis::set_longitude(float value) {

  longitude_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.longitude)
}

// optional float latitude = 2;
void Gis::clear_latitude() {
  latitude_ = 0;
}
 float Gis::latitude() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.latitude)
  return latitude_;
}
 void Gis::set_latitude(float value) {

  latitude_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.latitude)
}

// optional float width = 3;
void Gis::clear_width() {
  width_ = 0;
}
 float Gis::width() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.width)
  return width_;
}
 void Gis::set_width(float value) {

  width_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.width)
}

// optional float height = 4;
void Gis::clear_height() {
  height_ = 0;
}
 float Gis::height() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.height)
  return height_;
}
 void Gis::set_height(float value) {

  height_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.height)
}

// optional float orientation = 5;
void Gis::clear_orientation() {
  orientation_ = 0;
}
 float Gis::orientation() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.orientation)
  return orientation_;
}
 void Gis::set_orientation(float value) {

  orientation_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.orientation)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VehicleInfo::kTrackIdFieldNumber;
const int VehicleInfo::kTypeFieldNumber;
const int VehicleInfo::kColorFieldNumber;
const int VehicleInfo::kBoxFieldNumber;
const int VehicleInfo::kPointsFieldNumber;
const int VehicleInfo::kPlateInfoFieldNumber;
const int VehicleInfo::kLocationFieldNumber;
const int VehicleInfo::kLaneIdFieldNumber;
const int VehicleInfo::kSpeedFieldNumber;
const int VehicleInfo::kGisInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VehicleInfo::VehicleInfo()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.VehicleInfo)
}

void VehicleInfo::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  box_ = const_cast< ::vehicle::Box*>(
      ::vehicle::Box::internal_default_instance());
#else
  box_ = const_cast< ::vehicle::Box*>(&::vehicle::Box::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  points_ = const_cast< ::vehicle::Points*>(
      ::vehicle::Points::internal_default_instance());
#else
  points_ = const_cast< ::vehicle::Points*>(&::vehicle::Points::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  plate_info_ = const_cast< ::vehicle::Plate*>(
      ::vehicle::Plate::internal_default_instance());
#else
  plate_info_ = const_cast< ::vehicle::Plate*>(&::vehicle::Plate::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::vehicle::Point*>(
      ::vehicle::Point::internal_default_instance());
#else
  location_ = const_cast< ::vehicle::Point*>(&::vehicle::Point::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  gis_info_ = const_cast< ::vehicle::Gis*>(
      ::vehicle::Gis::internal_default_instance());
#else
  gis_info_ = const_cast< ::vehicle::Gis*>(&::vehicle::Gis::default_instance());
#endif
}

VehicleInfo::VehicleInfo(const VehicleInfo& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.VehicleInfo)
}

void VehicleInfo::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  track_id_ = GOOGLE_ULONGLONG(0);
  type_ = 0;
  color_ = 0;
  box_ = NULL;
  points_ = NULL;
  plate_info_ = NULL;
  location_ = NULL;
  lane_id_ = 0u;
  speed_ = 0;
  gis_info_ = NULL;
}

VehicleInfo::~VehicleInfo() {
  // @@protoc_insertion_point(destructor:vehicle.VehicleInfo)
  SharedDtor();
}

void VehicleInfo::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete box_;
    delete points_;
    delete plate_info_;
    delete location_;
    delete gis_info_;
  }
}

void VehicleInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VehicleInfo& VehicleInfo::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

VehicleInfo* VehicleInfo::default_instance_ = NULL;

VehicleInfo* VehicleInfo::New(::google::protobuf::Arena* arena) const {
  VehicleInfo* n = new VehicleInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VehicleInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.VehicleInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(VehicleInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<VehicleInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(track_id_, color_);
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
  if (GetArenaNoVirtual() == NULL && plate_info_ != NULL) delete plate_info_;
  plate_info_ = NULL;
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
  lane_id_ = 0u;
  speed_ = 0;
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;

#undef ZR_HELPER_
#undef ZR_

}

bool VehicleInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.VehicleInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 track_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &track_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional int32 type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_color;
        break;
      }

      // optional int32 color = 3;
      case 3: {
        if (tag == 24) {
         parse_color:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &color_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_box;
        break;
      }

      // optional .vehicle.Box box = 4;
      case 4: {
        if (tag == 34) {
         parse_box:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_points;
        break;
      }

      // optional .vehicle.Points points = 5;
      case 5: {
        if (tag == 42) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_plate_info;
        break;
      }

      // optional .vehicle.Plate plate_info = 6;
      case 6: {
        if (tag == 50) {
         parse_plate_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_plate_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_location;
        break;
      }

      // optional .vehicle.Point location = 7;
      case 7: {
        if (tag == 58) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_lane_id;
        break;
      }

      // optional uint32 lane_id = 8;
      case 8: {
        if (tag == 64) {
         parse_lane_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lane_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_speed;
        break;
      }

      // optional float speed = 9;
      case 9: {
        if (tag == 77) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_gis_info;
        break;
      }

      // optional .vehicle.Gis gis_info = 10;
      case 10: {
        if (tag == 82) {
         parse_gis_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gis_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.VehicleInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.VehicleInfo)
  return false;
#undef DO_
}

void VehicleInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.VehicleInfo)
  // optional uint64 track_id = 1;
  if (this->track_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->track_id(), output);
  }

  // optional int32 type = 2;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // optional int32 color = 3;
  if (this->color() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->color(), output);
  }

  // optional .vehicle.Box box = 4;
  if (this->has_box()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->box_, output);
  }

  // optional .vehicle.Points points = 5;
  if (this->has_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->points_, output);
  }

  // optional .vehicle.Plate plate_info = 6;
  if (this->has_plate_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      6, *this->plate_info_, output);
  }

  // optional .vehicle.Point location = 7;
  if (this->has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->location_, output);
  }

  // optional uint32 lane_id = 8;
  if (this->lane_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->lane_id(), output);
  }

  // optional float speed = 9;
  if (this->speed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->speed(), output);
  }

  // optional .vehicle.Gis gis_info = 10;
  if (this->has_gis_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      10, *this->gis_info_, output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.VehicleInfo)
}

int VehicleInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.VehicleInfo)
  int total_size = 0;

  // optional uint64 track_id = 1;
  if (this->track_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->track_id());
  }

  // optional int32 type = 2;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->type());
  }

  // optional int32 color = 3;
  if (this->color() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->color());
  }

  // optional .vehicle.Box box = 4;
  if (this->has_box()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->box_);
  }

  // optional .vehicle.Points points = 5;
  if (this->has_points()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->points_);
  }

  // optional .vehicle.Plate plate_info = 6;
  if (this->has_plate_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->plate_info_);
  }

  // optional .vehicle.Point location = 7;
  if (this->has_location()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->location_);
  }

  // optional uint32 lane_id = 8;
  if (this->lane_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->lane_id());
  }

  // optional float speed = 9;
  if (this->speed() != 0) {
    total_size += 1 + 4;
  }

  // optional .vehicle.Gis gis_info = 10;
  if (this->has_gis_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->gis_info_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VehicleInfo::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VehicleInfo*>(&from));
}

void VehicleInfo::MergeFrom(const VehicleInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.VehicleInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.track_id() != 0) {
    set_track_id(from.track_id());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.color() != 0) {
    set_color(from.color());
  }
  if (from.has_box()) {
    mutable_box()->::vehicle::Box::MergeFrom(from.box());
  }
  if (from.has_points()) {
    mutable_points()->::vehicle::Points::MergeFrom(from.points());
  }
  if (from.has_plate_info()) {
    mutable_plate_info()->::vehicle::Plate::MergeFrom(from.plate_info());
  }
  if (from.has_location()) {
    mutable_location()->::vehicle::Point::MergeFrom(from.location());
  }
  if (from.lane_id() != 0) {
    set_lane_id(from.lane_id());
  }
  if (from.speed() != 0) {
    set_speed(from.speed());
  }
  if (from.has_gis_info()) {
    mutable_gis_info()->::vehicle::Gis::MergeFrom(from.gis_info());
  }
}

void VehicleInfo::CopyFrom(const VehicleInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.VehicleInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleInfo::IsInitialized() const {

  return true;
}

void VehicleInfo::Swap(VehicleInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VehicleInfo::InternalSwap(VehicleInfo* other) {
  std::swap(track_id_, other->track_id_);
  std::swap(type_, other->type_);
  std::swap(color_, other->color_);
  std::swap(box_, other->box_);
  std::swap(points_, other->points_);
  std::swap(plate_info_, other->plate_info_);
  std::swap(location_, other->location_);
  std::swap(lane_id_, other->lane_id_);
  std::swap(speed_, other->speed_);
  std::swap(gis_info_, other->gis_info_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VehicleInfo::GetTypeName() const {
  return "vehicle.VehicleInfo";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VehicleInfo

// optional uint64 track_id = 1;
void VehicleInfo::clear_track_id() {
  track_id_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 VehicleInfo::track_id() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.track_id)
  return track_id_;
}
 void VehicleInfo::set_track_id(::google::protobuf::uint64 value) {

  track_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.track_id)
}

// optional int32 type = 2;
void VehicleInfo::clear_type() {
  type_ = 0;
}
 ::google::protobuf::int32 VehicleInfo::type() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.type)
  return type_;
}
 void VehicleInfo::set_type(::google::protobuf::int32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.type)
}

// optional int32 color = 3;
void VehicleInfo::clear_color() {
  color_ = 0;
}
 ::google::protobuf::int32 VehicleInfo::color() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.color)
  return color_;
}
 void VehicleInfo::set_color(::google::protobuf::int32 value) {

  color_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.color)
}

// optional .vehicle.Box box = 4;
bool VehicleInfo::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
void VehicleInfo::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
const ::vehicle::Box& VehicleInfo::box() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
::vehicle::Box* VehicleInfo::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.box)
  return box_;
}
::vehicle::Box* VehicleInfo::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.box)
}

// optional .vehicle.Points points = 5;
bool VehicleInfo::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
void VehicleInfo::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
const ::vehicle::Points& VehicleInfo::points() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
::vehicle::Points* VehicleInfo::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.points)
  return points_;
}
::vehicle::Points* VehicleInfo::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.points)
}

// optional .vehicle.Plate plate_info = 6;
bool VehicleInfo::has_plate_info() const {
  return !_is_default_instance_ && plate_info_ != NULL;
}
void VehicleInfo::clear_plate_info() {
  if (GetArenaNoVirtual() == NULL && plate_info_ != NULL) delete plate_info_;
  plate_info_ = NULL;
}
const ::vehicle::Plate& VehicleInfo::plate_info() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.plate_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return plate_info_ != NULL ? *plate_info_ : *default_instance().plate_info_;
#else
  return plate_info_ != NULL ? *plate_info_ : *default_instance_->plate_info_;
#endif
}
::vehicle::Plate* VehicleInfo::mutable_plate_info() {

  if (plate_info_ == NULL) {
    plate_info_ = new ::vehicle::Plate;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.plate_info)
  return plate_info_;
}
::vehicle::Plate* VehicleInfo::release_plate_info() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.plate_info)

  ::vehicle::Plate* temp = plate_info_;
  plate_info_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_plate_info(::vehicle::Plate* plate_info) {
  delete plate_info_;
  plate_info_ = plate_info;
  if (plate_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.plate_info)
}

// optional .vehicle.Point location = 7;
bool VehicleInfo::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
void VehicleInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
const ::vehicle::Point& VehicleInfo::location() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
::vehicle::Point* VehicleInfo::mutable_location() {

  if (location_ == NULL) {
    location_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.location)
  return location_;
}
::vehicle::Point* VehicleInfo::release_location() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.location)

  ::vehicle::Point* temp = location_;
  location_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_location(::vehicle::Point* location) {
  delete location_;
  location_ = location;
  if (location) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.location)
}

// optional uint32 lane_id = 8;
void VehicleInfo::clear_lane_id() {
  lane_id_ = 0u;
}
 ::google::protobuf::uint32 VehicleInfo::lane_id() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.lane_id)
  return lane_id_;
}
 void VehicleInfo::set_lane_id(::google::protobuf::uint32 value) {

  lane_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.lane_id)
}

// optional float speed = 9;
void VehicleInfo::clear_speed() {
  speed_ = 0;
}
 float VehicleInfo::speed() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.speed)
  return speed_;
}
 void VehicleInfo::set_speed(float value) {

  speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.speed)
}

// optional .vehicle.Gis gis_info = 10;
bool VehicleInfo::has_gis_info() const {
  return !_is_default_instance_ && gis_info_ != NULL;
}
void VehicleInfo::clear_gis_info() {
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;
}
const ::vehicle::Gis& VehicleInfo::gis_info() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.gis_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gis_info_ != NULL ? *gis_info_ : *default_instance().gis_info_;
#else
  return gis_info_ != NULL ? *gis_info_ : *default_instance_->gis_info_;
#endif
}
::vehicle::Gis* VehicleInfo::mutable_gis_info() {

  if (gis_info_ == NULL) {
    gis_info_ = new ::vehicle::Gis;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.gis_info)
  return gis_info_;
}
::vehicle::Gis* VehicleInfo::release_gis_info() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.gis_info)

  ::vehicle::Gis* temp = gis_info_;
  gis_info_ = NULL;
  return temp;
}
void VehicleInfo::set_allocated_gis_info(::vehicle::Gis* gis_info) {
  delete gis_info_;
  gis_info_ = gis_info;
  if (gis_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.gis_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Nonmotor::kTrackIdFieldNumber;
const int Nonmotor::kBoxFieldNumber;
const int Nonmotor::kPointsFieldNumber;
const int Nonmotor::kLocationFieldNumber;
const int Nonmotor::kLaneIdFieldNumber;
const int Nonmotor::kSpeedFieldNumber;
const int Nonmotor::kGisInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Nonmotor::Nonmotor()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Nonmotor)
}

void Nonmotor::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  box_ = const_cast< ::vehicle::Box*>(
      ::vehicle::Box::internal_default_instance());
#else
  box_ = const_cast< ::vehicle::Box*>(&::vehicle::Box::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  points_ = const_cast< ::vehicle::Points*>(
      ::vehicle::Points::internal_default_instance());
#else
  points_ = const_cast< ::vehicle::Points*>(&::vehicle::Points::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::vehicle::Point*>(
      ::vehicle::Point::internal_default_instance());
#else
  location_ = const_cast< ::vehicle::Point*>(&::vehicle::Point::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  gis_info_ = const_cast< ::vehicle::Gis*>(
      ::vehicle::Gis::internal_default_instance());
#else
  gis_info_ = const_cast< ::vehicle::Gis*>(&::vehicle::Gis::default_instance());
#endif
}

Nonmotor::Nonmotor(const Nonmotor& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Nonmotor)
}

void Nonmotor::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  track_id_ = GOOGLE_ULONGLONG(0);
  box_ = NULL;
  points_ = NULL;
  location_ = NULL;
  lane_id_ = 0u;
  speed_ = 0;
  gis_info_ = NULL;
}

Nonmotor::~Nonmotor() {
  // @@protoc_insertion_point(destructor:vehicle.Nonmotor)
  SharedDtor();
}

void Nonmotor::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete box_;
    delete points_;
    delete location_;
    delete gis_info_;
  }
}

void Nonmotor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Nonmotor& Nonmotor::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Nonmotor* Nonmotor::default_instance_ = NULL;

Nonmotor* Nonmotor::New(::google::protobuf::Arena* arena) const {
  Nonmotor* n = new Nonmotor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Nonmotor::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Nonmotor)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Nonmotor, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Nonmotor*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(lane_id_, speed_);
  track_id_ = GOOGLE_ULONGLONG(0);
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;

#undef ZR_HELPER_
#undef ZR_

}

bool Nonmotor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Nonmotor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 track_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &track_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_box;
        break;
      }

      // optional .vehicle.Box box = 2;
      case 2: {
        if (tag == 18) {
         parse_box:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_points;
        break;
      }

      // optional .vehicle.Points points = 3;
      case 3: {
        if (tag == 26) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // optional .vehicle.Point location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_lane_id;
        break;
      }

      // optional uint32 lane_id = 5;
      case 5: {
        if (tag == 40) {
         parse_lane_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lane_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_speed;
        break;
      }

      // optional float speed = 6;
      case 6: {
        if (tag == 53) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_gis_info;
        break;
      }

      // optional .vehicle.Gis gis_info = 7;
      case 7: {
        if (tag == 58) {
         parse_gis_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gis_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Nonmotor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Nonmotor)
  return false;
#undef DO_
}

void Nonmotor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Nonmotor)
  // optional uint64 track_id = 1;
  if (this->track_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->track_id(), output);
  }

  // optional .vehicle.Box box = 2;
  if (this->has_box()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->box_, output);
  }

  // optional .vehicle.Points points = 3;
  if (this->has_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->points_, output);
  }

  // optional .vehicle.Point location = 4;
  if (this->has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->location_, output);
  }

  // optional uint32 lane_id = 5;
  if (this->lane_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->lane_id(), output);
  }

  // optional float speed = 6;
  if (this->speed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->speed(), output);
  }

  // optional .vehicle.Gis gis_info = 7;
  if (this->has_gis_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->gis_info_, output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Nonmotor)
}

int Nonmotor::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Nonmotor)
  int total_size = 0;

  // optional uint64 track_id = 1;
  if (this->track_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->track_id());
  }

  // optional .vehicle.Box box = 2;
  if (this->has_box()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->box_);
  }

  // optional .vehicle.Points points = 3;
  if (this->has_points()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->points_);
  }

  // optional .vehicle.Point location = 4;
  if (this->has_location()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->location_);
  }

  // optional uint32 lane_id = 5;
  if (this->lane_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->lane_id());
  }

  // optional float speed = 6;
  if (this->speed() != 0) {
    total_size += 1 + 4;
  }

  // optional .vehicle.Gis gis_info = 7;
  if (this->has_gis_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->gis_info_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Nonmotor::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Nonmotor*>(&from));
}

void Nonmotor::MergeFrom(const Nonmotor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Nonmotor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.track_id() != 0) {
    set_track_id(from.track_id());
  }
  if (from.has_box()) {
    mutable_box()->::vehicle::Box::MergeFrom(from.box());
  }
  if (from.has_points()) {
    mutable_points()->::vehicle::Points::MergeFrom(from.points());
  }
  if (from.has_location()) {
    mutable_location()->::vehicle::Point::MergeFrom(from.location());
  }
  if (from.lane_id() != 0) {
    set_lane_id(from.lane_id());
  }
  if (from.speed() != 0) {
    set_speed(from.speed());
  }
  if (from.has_gis_info()) {
    mutable_gis_info()->::vehicle::Gis::MergeFrom(from.gis_info());
  }
}

void Nonmotor::CopyFrom(const Nonmotor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Nonmotor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Nonmotor::IsInitialized() const {

  return true;
}

void Nonmotor::Swap(Nonmotor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Nonmotor::InternalSwap(Nonmotor* other) {
  std::swap(track_id_, other->track_id_);
  std::swap(box_, other->box_);
  std::swap(points_, other->points_);
  std::swap(location_, other->location_);
  std::swap(lane_id_, other->lane_id_);
  std::swap(speed_, other->speed_);
  std::swap(gis_info_, other->gis_info_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Nonmotor::GetTypeName() const {
  return "vehicle.Nonmotor";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Nonmotor

// optional uint64 track_id = 1;
void Nonmotor::clear_track_id() {
  track_id_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Nonmotor::track_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.track_id)
  return track_id_;
}
 void Nonmotor::set_track_id(::google::protobuf::uint64 value) {

  track_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Nonmotor.track_id)
}

// optional .vehicle.Box box = 2;
bool Nonmotor::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
void Nonmotor::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
const ::vehicle::Box& Nonmotor::box() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
::vehicle::Box* Nonmotor::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.box)
  return box_;
}
::vehicle::Box* Nonmotor::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
void Nonmotor::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.box)
}

// optional .vehicle.Points points = 3;
bool Nonmotor::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
void Nonmotor::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
const ::vehicle::Points& Nonmotor::points() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
::vehicle::Points* Nonmotor::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.points)
  return points_;
}
::vehicle::Points* Nonmotor::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
void Nonmotor::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.points)
}

// optional .vehicle.Point location = 4;
bool Nonmotor::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
void Nonmotor::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
const ::vehicle::Point& Nonmotor::location() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
::vehicle::Point* Nonmotor::mutable_location() {

  if (location_ == NULL) {
    location_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.location)
  return location_;
}
::vehicle::Point* Nonmotor::release_location() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.location)

  ::vehicle::Point* temp = location_;
  location_ = NULL;
  return temp;
}
void Nonmotor::set_allocated_location(::vehicle::Point* location) {
  delete location_;
  location_ = location;
  if (location) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.location)
}

// optional uint32 lane_id = 5;
void Nonmotor::clear_lane_id() {
  lane_id_ = 0u;
}
 ::google::protobuf::uint32 Nonmotor::lane_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.lane_id)
  return lane_id_;
}
 void Nonmotor::set_lane_id(::google::protobuf::uint32 value) {

  lane_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Nonmotor.lane_id)
}

// optional float speed = 6;
void Nonmotor::clear_speed() {
  speed_ = 0;
}
 float Nonmotor::speed() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.speed)
  return speed_;
}
 void Nonmotor::set_speed(float value) {

  speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Nonmotor.speed)
}

// optional .vehicle.Gis gis_info = 7;
bool Nonmotor::has_gis_info() const {
  return !_is_default_instance_ && gis_info_ != NULL;
}
void Nonmotor::clear_gis_info() {
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;
}
const ::vehicle::Gis& Nonmotor::gis_info() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.gis_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gis_info_ != NULL ? *gis_info_ : *default_instance().gis_info_;
#else
  return gis_info_ != NULL ? *gis_info_ : *default_instance_->gis_info_;
#endif
}
::vehicle::Gis* Nonmotor::mutable_gis_info() {

  if (gis_info_ == NULL) {
    gis_info_ = new ::vehicle::Gis;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.gis_info)
  return gis_info_;
}
::vehicle::Gis* Nonmotor::release_gis_info() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.gis_info)

  ::vehicle::Gis* temp = gis_info_;
  gis_info_ = NULL;
  return temp;
}
void Nonmotor::set_allocated_gis_info(::vehicle::Gis* gis_info) {
  delete gis_info_;
  gis_info_ = gis_info;
  if (gis_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.gis_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Person::kTrackIdFieldNumber;
const int Person::kBoxFieldNumber;
const int Person::kPointsFieldNumber;
const int Person::kLocationFieldNumber;
const int Person::kLaneIdFieldNumber;
const int Person::kSpeedFieldNumber;
const int Person::kGisInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Person::Person()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Person)
}

void Person::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  box_ = const_cast< ::vehicle::Box*>(
      ::vehicle::Box::internal_default_instance());
#else
  box_ = const_cast< ::vehicle::Box*>(&::vehicle::Box::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  points_ = const_cast< ::vehicle::Points*>(
      ::vehicle::Points::internal_default_instance());
#else
  points_ = const_cast< ::vehicle::Points*>(&::vehicle::Points::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  location_ = const_cast< ::vehicle::Point*>(
      ::vehicle::Point::internal_default_instance());
#else
  location_ = const_cast< ::vehicle::Point*>(&::vehicle::Point::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  gis_info_ = const_cast< ::vehicle::Gis*>(
      ::vehicle::Gis::internal_default_instance());
#else
  gis_info_ = const_cast< ::vehicle::Gis*>(&::vehicle::Gis::default_instance());
#endif
}

Person::Person(const Person& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Person)
}

void Person::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  track_id_ = GOOGLE_ULONGLONG(0);
  box_ = NULL;
  points_ = NULL;
  location_ = NULL;
  lane_id_ = 0u;
  speed_ = 0;
  gis_info_ = NULL;
}

Person::~Person() {
  // @@protoc_insertion_point(destructor:vehicle.Person)
  SharedDtor();
}

void Person::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete box_;
    delete points_;
    delete location_;
    delete gis_info_;
  }
}

void Person::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Person& Person::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Person* Person::default_instance_ = NULL;

Person* Person::New(::google::protobuf::Arena* arena) const {
  Person* n = new Person;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Person::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Person)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Person, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Person*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(lane_id_, speed_);
  track_id_ = GOOGLE_ULONGLONG(0);
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;

#undef ZR_HELPER_
#undef ZR_

}

bool Person::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Person)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint64 track_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &track_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_box;
        break;
      }

      // optional .vehicle.Box box = 2;
      case 2: {
        if (tag == 18) {
         parse_box:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_box()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_points;
        break;
      }

      // optional .vehicle.Points points = 3;
      case 3: {
        if (tag == 26) {
         parse_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // optional .vehicle.Point location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_lane_id;
        break;
      }

      // optional uint32 lane_id = 5;
      case 5: {
        if (tag == 40) {
         parse_lane_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &lane_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_speed;
        break;
      }

      // optional float speed = 6;
      case 6: {
        if (tag == 53) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &speed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_gis_info;
        break;
      }

      // optional .vehicle.Gis gis_info = 7;
      case 7: {
        if (tag == 58) {
         parse_gis_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gis_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Person)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Person)
  return false;
#undef DO_
}

void Person::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Person)
  // optional uint64 track_id = 1;
  if (this->track_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->track_id(), output);
  }

  // optional .vehicle.Box box = 2;
  if (this->has_box()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->box_, output);
  }

  // optional .vehicle.Points points = 3;
  if (this->has_points()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->points_, output);
  }

  // optional .vehicle.Point location = 4;
  if (this->has_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->location_, output);
  }

  // optional uint32 lane_id = 5;
  if (this->lane_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->lane_id(), output);
  }

  // optional float speed = 6;
  if (this->speed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->speed(), output);
  }

  // optional .vehicle.Gis gis_info = 7;
  if (this->has_gis_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      7, *this->gis_info_, output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Person)
}

int Person::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Person)
  int total_size = 0;

  // optional uint64 track_id = 1;
  if (this->track_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->track_id());
  }

  // optional .vehicle.Box box = 2;
  if (this->has_box()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->box_);
  }

  // optional .vehicle.Points points = 3;
  if (this->has_points()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->points_);
  }

  // optional .vehicle.Point location = 4;
  if (this->has_location()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->location_);
  }

  // optional uint32 lane_id = 5;
  if (this->lane_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->lane_id());
  }

  // optional float speed = 6;
  if (this->speed() != 0) {
    total_size += 1 + 4;
  }

  // optional .vehicle.Gis gis_info = 7;
  if (this->has_gis_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->gis_info_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Person::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Person*>(&from));
}

void Person::MergeFrom(const Person& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Person)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.track_id() != 0) {
    set_track_id(from.track_id());
  }
  if (from.has_box()) {
    mutable_box()->::vehicle::Box::MergeFrom(from.box());
  }
  if (from.has_points()) {
    mutable_points()->::vehicle::Points::MergeFrom(from.points());
  }
  if (from.has_location()) {
    mutable_location()->::vehicle::Point::MergeFrom(from.location());
  }
  if (from.lane_id() != 0) {
    set_lane_id(from.lane_id());
  }
  if (from.speed() != 0) {
    set_speed(from.speed());
  }
  if (from.has_gis_info()) {
    mutable_gis_info()->::vehicle::Gis::MergeFrom(from.gis_info());
  }
}

void Person::CopyFrom(const Person& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Person)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Person::IsInitialized() const {

  return true;
}

void Person::Swap(Person* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Person::InternalSwap(Person* other) {
  std::swap(track_id_, other->track_id_);
  std::swap(box_, other->box_);
  std::swap(points_, other->points_);
  std::swap(location_, other->location_);
  std::swap(lane_id_, other->lane_id_);
  std::swap(speed_, other->speed_);
  std::swap(gis_info_, other->gis_info_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Person::GetTypeName() const {
  return "vehicle.Person";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Person

// optional uint64 track_id = 1;
void Person::clear_track_id() {
  track_id_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 Person::track_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.track_id)
  return track_id_;
}
 void Person::set_track_id(::google::protobuf::uint64 value) {

  track_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Person.track_id)
}

// optional .vehicle.Box box = 2;
bool Person::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
void Person::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
const ::vehicle::Box& Person::box() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
::vehicle::Box* Person::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.box)
  return box_;
}
::vehicle::Box* Person::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.Person.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
void Person::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.box)
}

// optional .vehicle.Points points = 3;
bool Person::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
void Person::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
const ::vehicle::Points& Person::points() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
::vehicle::Points* Person::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.points)
  return points_;
}
::vehicle::Points* Person::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.Person.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
void Person::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.points)
}

// optional .vehicle.Point location = 4;
bool Person::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
void Person::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
const ::vehicle::Point& Person::location() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
::vehicle::Point* Person::mutable_location() {

  if (location_ == NULL) {
    location_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.location)
  return location_;
}
::vehicle::Point* Person::release_location() {
  // @@protoc_insertion_point(field_release:vehicle.Person.location)

  ::vehicle::Point* temp = location_;
  location_ = NULL;
  return temp;
}
void Person::set_allocated_location(::vehicle::Point* location) {
  delete location_;
  location_ = location;
  if (location) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.location)
}

// optional uint32 lane_id = 5;
void Person::clear_lane_id() {
  lane_id_ = 0u;
}
 ::google::protobuf::uint32 Person::lane_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.lane_id)
  return lane_id_;
}
 void Person::set_lane_id(::google::protobuf::uint32 value) {

  lane_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Person.lane_id)
}

// optional float speed = 6;
void Person::clear_speed() {
  speed_ = 0;
}
 float Person::speed() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.speed)
  return speed_;
}
 void Person::set_speed(float value) {

  speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Person.speed)
}

// optional .vehicle.Gis gis_info = 7;
bool Person::has_gis_info() const {
  return !_is_default_instance_ && gis_info_ != NULL;
}
void Person::clear_gis_info() {
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;
}
const ::vehicle::Gis& Person::gis_info() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.gis_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gis_info_ != NULL ? *gis_info_ : *default_instance().gis_info_;
#else
  return gis_info_ != NULL ? *gis_info_ : *default_instance_->gis_info_;
#endif
}
::vehicle::Gis* Person::mutable_gis_info() {

  if (gis_info_ == NULL) {
    gis_info_ = new ::vehicle::Gis;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.gis_info)
  return gis_info_;
}
::vehicle::Gis* Person::release_gis_info() {
  // @@protoc_insertion_point(field_release:vehicle.Person.gis_info)

  ::vehicle::Gis* temp = gis_info_;
  gis_info_ = NULL;
  return temp;
}
void Person::set_allocated_gis_info(::vehicle::Gis* gis_info) {
  delete gis_info_;
  gis_info_ = gis_info;
  if (gis_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.gis_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficCondition::kTimestampFieldNumber;
const int TrafficCondition::kTypeFieldNumber;
const int TrafficCondition::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficCondition::TrafficCondition()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.TrafficCondition)
}

void TrafficCondition::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TrafficCondition::TrafficCondition(const TrafficCondition& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.TrafficCondition)
}

void TrafficCondition::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  type_ = 0u;
  value_ = 0;
}

TrafficCondition::~TrafficCondition() {
  // @@protoc_insertion_point(destructor:vehicle.TrafficCondition)
  SharedDtor();
}

void TrafficCondition::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TrafficCondition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TrafficCondition& TrafficCondition::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

TrafficCondition* TrafficCondition::default_instance_ = NULL;

TrafficCondition* TrafficCondition::New(::google::protobuf::Arena* arena) const {
  TrafficCondition* n = new TrafficCondition;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficCondition::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.TrafficCondition)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TrafficCondition, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrafficCondition*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(timestamp_, value_);

#undef ZR_HELPER_
#undef ZR_

}

bool TrafficCondition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.TrafficCondition)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &timestamp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional uint32 type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_value;
        break;
      }

      // optional float value = 3;
      case 3: {
        if (tag == 29) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &value_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.TrafficCondition)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.TrafficCondition)
  return false;
#undef DO_
}

void TrafficCondition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.TrafficCondition)
  // optional fixed64 timestamp = 1;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->timestamp(), output);
  }

  // optional uint32 type = 2;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->type(), output);
  }

  // optional float value = 3;
  if (this->value() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->value(), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.TrafficCondition)
}

int TrafficCondition::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.TrafficCondition)
  int total_size = 0;

  // optional fixed64 timestamp = 1;
  if (this->timestamp() != 0) {
    total_size += 1 + 8;
  }

  // optional uint32 type = 2;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->type());
  }

  // optional float value = 3;
  if (this->value() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficCondition::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TrafficCondition*>(&from));
}

void TrafficCondition::MergeFrom(const TrafficCondition& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.TrafficCondition)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.value() != 0) {
    set_value(from.value());
  }
}

void TrafficCondition::CopyFrom(const TrafficCondition& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.TrafficCondition)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficCondition::IsInitialized() const {

  return true;
}

void TrafficCondition::Swap(TrafficCondition* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficCondition::InternalSwap(TrafficCondition* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(type_, other->type_);
  std::swap(value_, other->value_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TrafficCondition::GetTypeName() const {
  return "vehicle.TrafficCondition";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrafficCondition

// optional fixed64 timestamp = 1;
void TrafficCondition::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 TrafficCondition::timestamp() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficCondition.timestamp)
  return timestamp_;
}
 void TrafficCondition::set_timestamp(::google::protobuf::uint64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficCondition.timestamp)
}

// optional uint32 type = 2;
void TrafficCondition::clear_type() {
  type_ = 0u;
}
 ::google::protobuf::uint32 TrafficCondition::type() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficCondition.type)
  return type_;
}
 void TrafficCondition::set_type(::google::protobuf::uint32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficCondition.type)
}

// optional float value = 3;
void TrafficCondition::clear_value() {
  value_ = 0;
}
 float TrafficCondition::value() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficCondition.value)
  return value_;
}
 void TrafficCondition::set_value(float value) {

  value_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficCondition.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficFlow::kHourIndexFieldNumber;
const int TrafficFlow::kCycleCountFieldNumber;
const int TrafficFlow::kCycleMinuteFieldNumber;
const int TrafficFlow::kVehicleSumFieldNumber;
const int TrafficFlow::kBigVehicleSumFieldNumber;
const int TrafficFlow::kSmallVehicleSumFieldNumber;
const int TrafficFlow::kMeanSpeedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficFlow::TrafficFlow()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.TrafficFlow)
}

void TrafficFlow::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

TrafficFlow::TrafficFlow(const TrafficFlow& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.TrafficFlow)
}

void TrafficFlow::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  hour_index_ = 0u;
  cycle_count_ = 0u;
  cycle_minute_ = 0u;
  vehicle_sum_ = 0u;
  big_vehicle_sum_ = 0u;
  small_vehicle_sum_ = 0u;
  mean_speed_ = 0;
}

TrafficFlow::~TrafficFlow() {
  // @@protoc_insertion_point(destructor:vehicle.TrafficFlow)
  SharedDtor();
}

void TrafficFlow::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void TrafficFlow::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const TrafficFlow& TrafficFlow::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

TrafficFlow* TrafficFlow::default_instance_ = NULL;

TrafficFlow* TrafficFlow::New(::google::protobuf::Arena* arena) const {
  TrafficFlow* n = new TrafficFlow;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficFlow::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.TrafficFlow)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TrafficFlow, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrafficFlow*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(hour_index_, mean_speed_);

#undef ZR_HELPER_
#undef ZR_

}

bool TrafficFlow::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.TrafficFlow)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 hour_index = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hour_index_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_cycle_count;
        break;
      }

      // optional uint32 cycle_count = 2;
      case 2: {
        if (tag == 16) {
         parse_cycle_count:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cycle_count_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_cycle_minute;
        break;
      }

      // optional uint32 cycle_minute = 3;
      case 3: {
        if (tag == 24) {
         parse_cycle_minute:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cycle_minute_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_vehicle_sum;
        break;
      }

      // optional uint32 vehicle_sum = 4;
      case 4: {
        if (tag == 32) {
         parse_vehicle_sum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &vehicle_sum_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_big_vehicle_sum;
        break;
      }

      // optional uint32 big_vehicle_sum = 5;
      case 5: {
        if (tag == 40) {
         parse_big_vehicle_sum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &big_vehicle_sum_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_small_vehicle_sum;
        break;
      }

      // optional uint32 small_vehicle_sum = 6;
      case 6: {
        if (tag == 48) {
         parse_small_vehicle_sum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &small_vehicle_sum_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_mean_speed;
        break;
      }

      // optional float mean_speed = 7;
      case 7: {
        if (tag == 61) {
         parse_mean_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mean_speed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.TrafficFlow)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.TrafficFlow)
  return false;
#undef DO_
}

void TrafficFlow::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.TrafficFlow)
  // optional uint32 hour_index = 1;
  if (this->hour_index() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->hour_index(), output);
  }

  // optional uint32 cycle_count = 2;
  if (this->cycle_count() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->cycle_count(), output);
  }

  // optional uint32 cycle_minute = 3;
  if (this->cycle_minute() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->cycle_minute(), output);
  }

  // optional uint32 vehicle_sum = 4;
  if (this->vehicle_sum() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->vehicle_sum(), output);
  }

  // optional uint32 big_vehicle_sum = 5;
  if (this->big_vehicle_sum() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->big_vehicle_sum(), output);
  }

  // optional uint32 small_vehicle_sum = 6;
  if (this->small_vehicle_sum() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(6, this->small_vehicle_sum(), output);
  }

  // optional float mean_speed = 7;
  if (this->mean_speed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->mean_speed(), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.TrafficFlow)
}

int TrafficFlow::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.TrafficFlow)
  int total_size = 0;

  // optional uint32 hour_index = 1;
  if (this->hour_index() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->hour_index());
  }

  // optional uint32 cycle_count = 2;
  if (this->cycle_count() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cycle_count());
  }

  // optional uint32 cycle_minute = 3;
  if (this->cycle_minute() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->cycle_minute());
  }

  // optional uint32 vehicle_sum = 4;
  if (this->vehicle_sum() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->vehicle_sum());
  }

  // optional uint32 big_vehicle_sum = 5;
  if (this->big_vehicle_sum() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->big_vehicle_sum());
  }

  // optional uint32 small_vehicle_sum = 6;
  if (this->small_vehicle_sum() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->small_vehicle_sum());
  }

  // optional float mean_speed = 7;
  if (this->mean_speed() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficFlow::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const TrafficFlow*>(&from));
}

void TrafficFlow::MergeFrom(const TrafficFlow& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.TrafficFlow)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.hour_index() != 0) {
    set_hour_index(from.hour_index());
  }
  if (from.cycle_count() != 0) {
    set_cycle_count(from.cycle_count());
  }
  if (from.cycle_minute() != 0) {
    set_cycle_minute(from.cycle_minute());
  }
  if (from.vehicle_sum() != 0) {
    set_vehicle_sum(from.vehicle_sum());
  }
  if (from.big_vehicle_sum() != 0) {
    set_big_vehicle_sum(from.big_vehicle_sum());
  }
  if (from.small_vehicle_sum() != 0) {
    set_small_vehicle_sum(from.small_vehicle_sum());
  }
  if (from.mean_speed() != 0) {
    set_mean_speed(from.mean_speed());
  }
}

void TrafficFlow::CopyFrom(const TrafficFlow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.TrafficFlow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficFlow::IsInitialized() const {

  return true;
}

void TrafficFlow::Swap(TrafficFlow* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficFlow::InternalSwap(TrafficFlow* other) {
  std::swap(hour_index_, other->hour_index_);
  std::swap(cycle_count_, other->cycle_count_);
  std::swap(cycle_minute_, other->cycle_minute_);
  std::swap(vehicle_sum_, other->vehicle_sum_);
  std::swap(big_vehicle_sum_, other->big_vehicle_sum_);
  std::swap(small_vehicle_sum_, other->small_vehicle_sum_);
  std::swap(mean_speed_, other->mean_speed_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string TrafficFlow::GetTypeName() const {
  return "vehicle.TrafficFlow";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrafficFlow

// optional uint32 hour_index = 1;
void TrafficFlow::clear_hour_index() {
  hour_index_ = 0u;
}
 ::google::protobuf::uint32 TrafficFlow::hour_index() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.hour_index)
  return hour_index_;
}
 void TrafficFlow::set_hour_index(::google::protobuf::uint32 value) {

  hour_index_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.hour_index)
}

// optional uint32 cycle_count = 2;
void TrafficFlow::clear_cycle_count() {
  cycle_count_ = 0u;
}
 ::google::protobuf::uint32 TrafficFlow::cycle_count() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.cycle_count)
  return cycle_count_;
}
 void TrafficFlow::set_cycle_count(::google::protobuf::uint32 value) {

  cycle_count_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.cycle_count)
}

// optional uint32 cycle_minute = 3;
void TrafficFlow::clear_cycle_minute() {
  cycle_minute_ = 0u;
}
 ::google::protobuf::uint32 TrafficFlow::cycle_minute() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.cycle_minute)
  return cycle_minute_;
}
 void TrafficFlow::set_cycle_minute(::google::protobuf::uint32 value) {

  cycle_minute_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.cycle_minute)
}

// optional uint32 vehicle_sum = 4;
void TrafficFlow::clear_vehicle_sum() {
  vehicle_sum_ = 0u;
}
 ::google::protobuf::uint32 TrafficFlow::vehicle_sum() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.vehicle_sum)
  return vehicle_sum_;
}
 void TrafficFlow::set_vehicle_sum(::google::protobuf::uint32 value) {

  vehicle_sum_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.vehicle_sum)
}

// optional uint32 big_vehicle_sum = 5;
void TrafficFlow::clear_big_vehicle_sum() {
  big_vehicle_sum_ = 0u;
}
 ::google::protobuf::uint32 TrafficFlow::big_vehicle_sum() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.big_vehicle_sum)
  return big_vehicle_sum_;
}
 void TrafficFlow::set_big_vehicle_sum(::google::protobuf::uint32 value) {

  big_vehicle_sum_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.big_vehicle_sum)
}

// optional uint32 small_vehicle_sum = 6;
void TrafficFlow::clear_small_vehicle_sum() {
  small_vehicle_sum_ = 0u;
}
 ::google::protobuf::uint32 TrafficFlow::small_vehicle_sum() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.small_vehicle_sum)
  return small_vehicle_sum_;
}
 void TrafficFlow::set_small_vehicle_sum(::google::protobuf::uint32 value) {

  small_vehicle_sum_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.small_vehicle_sum)
}

// optional float mean_speed = 7;
void TrafficFlow::clear_mean_speed() {
  mean_speed_ = 0;
}
 float TrafficFlow::mean_speed() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.mean_speed)
  return mean_speed_;
}
 void TrafficFlow::set_mean_speed(float value) {

  mean_speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.mean_speed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Anomaly::kTypeFieldNumber;
const int Anomaly::kVehicleCapturesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Anomaly::Anomaly()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.Anomaly)
}

void Anomaly::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Anomaly::Anomaly(const Anomaly& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.Anomaly)
}

void Anomaly::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  type_ = 0;
}

Anomaly::~Anomaly() {
  // @@protoc_insertion_point(destructor:vehicle.Anomaly)
  SharedDtor();
}

void Anomaly::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
  }
}

void Anomaly::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const Anomaly& Anomaly::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

Anomaly* Anomaly::default_instance_ = NULL;

Anomaly* Anomaly::New(::google::protobuf::Arena* arena) const {
  Anomaly* n = new Anomaly;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Anomaly::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.Anomaly)
  type_ = 0;
  vehicle_captures_.Clear();
}

bool Anomaly::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.Anomaly)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 type = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vehicle_captures;
        break;
      }

      // repeated .vehicle.VehicleCapture vehicle_captures = 2;
      case 2: {
        if (tag == 18) {
         parse_vehicle_captures:
          DO_(input->IncrementRecursionDepth());
         parse_loop_vehicle_captures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_vehicle_captures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_vehicle_captures;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.Anomaly)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.Anomaly)
  return false;
#undef DO_
}

void Anomaly::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.Anomaly)
  // optional int32 type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->type(), output);
  }

  // repeated .vehicle.VehicleCapture vehicle_captures = 2;
  for (unsigned int i = 0, n = this->vehicle_captures_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->vehicle_captures(i), output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.Anomaly)
}

int Anomaly::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.Anomaly)
  int total_size = 0;

  // optional int32 type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->type());
  }

  // repeated .vehicle.VehicleCapture vehicle_captures = 2;
  total_size += 1 * this->vehicle_captures_size();
  for (int i = 0; i < this->vehicle_captures_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vehicle_captures(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Anomaly::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const Anomaly*>(&from));
}

void Anomaly::MergeFrom(const Anomaly& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.Anomaly)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  vehicle_captures_.MergeFrom(from.vehicle_captures_);
  if (from.type() != 0) {
    set_type(from.type());
  }
}

void Anomaly::CopyFrom(const Anomaly& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.Anomaly)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Anomaly::IsInitialized() const {

  return true;
}

void Anomaly::Swap(Anomaly* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Anomaly::InternalSwap(Anomaly* other) {
  std::swap(type_, other->type_);
  vehicle_captures_.UnsafeArenaSwap(&other->vehicle_captures_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string Anomaly::GetTypeName() const {
  return "vehicle.Anomaly";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Anomaly

// optional int32 type = 1;
void Anomaly::clear_type() {
  type_ = 0;
}
 ::google::protobuf::int32 Anomaly::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Anomaly.type)
  return type_;
}
 void Anomaly::set_type(::google::protobuf::int32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Anomaly.type)
}

// repeated .vehicle.VehicleCapture vehicle_captures = 2;
int Anomaly::vehicle_captures_size() const {
  return vehicle_captures_.size();
}
void Anomaly::clear_vehicle_captures() {
  vehicle_captures_.Clear();
}
const ::vehicle::VehicleCapture& Anomaly::vehicle_captures(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_.Get(index);
}
::vehicle::VehicleCapture* Anomaly::mutable_vehicle_captures(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_.Mutable(index);
}
::vehicle::VehicleCapture* Anomaly::add_vehicle_captures() {
  // @@protoc_insertion_point(field_add:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >*
Anomaly::mutable_vehicle_captures() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.Anomaly.vehicle_captures)
  return &vehicle_captures_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >&
Anomaly::vehicle_captures() const {
  // @@protoc_insertion_point(field_list:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VehicleCapture::kTimestampFieldNumber;
const int VehicleCapture::kVehicleFieldNumber;
const int VehicleCapture::kImageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VehicleCapture::VehicleCapture()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.VehicleCapture)
}

void VehicleCapture::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  vehicle_ = const_cast< ::vehicle::VehicleInfo*>(
      ::vehicle::VehicleInfo::internal_default_instance());
#else
  vehicle_ = const_cast< ::vehicle::VehicleInfo*>(&::vehicle::VehicleInfo::default_instance());
#endif
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  image_ = const_cast< ::vehicle::Image*>(
      ::vehicle::Image::internal_default_instance());
#else
  image_ = const_cast< ::vehicle::Image*>(&::vehicle::Image::default_instance());
#endif
}

VehicleCapture::VehicleCapture(const VehicleCapture& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.VehicleCapture)
}

void VehicleCapture::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  vehicle_ = NULL;
  image_ = NULL;
}

VehicleCapture::~VehicleCapture() {
  // @@protoc_insertion_point(destructor:vehicle.VehicleCapture)
  SharedDtor();
}

void VehicleCapture::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete vehicle_;
    delete image_;
  }
}

void VehicleCapture::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const VehicleCapture& VehicleCapture::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

VehicleCapture* VehicleCapture::default_instance_ = NULL;

VehicleCapture* VehicleCapture::New(::google::protobuf::Arena* arena) const {
  VehicleCapture* n = new VehicleCapture;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VehicleCapture::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.VehicleCapture)
  timestamp_ = GOOGLE_ULONGLONG(0);
  if (GetArenaNoVirtual() == NULL && vehicle_ != NULL) delete vehicle_;
  vehicle_ = NULL;
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}

bool VehicleCapture::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.VehicleCapture)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &timestamp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vehicle;
        break;
      }

      // optional .vehicle.VehicleInfo vehicle = 2;
      case 2: {
        if (tag == 18) {
         parse_vehicle:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_vehicle()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_image;
        break;
      }

      // optional .vehicle.Image image = 3;
      case 3: {
        if (tag == 26) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.VehicleCapture)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.VehicleCapture)
  return false;
#undef DO_
}

void VehicleCapture::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.VehicleCapture)
  // optional fixed64 timestamp = 1;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->timestamp(), output);
  }

  // optional .vehicle.VehicleInfo vehicle = 2;
  if (this->has_vehicle()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, *this->vehicle_, output);
  }

  // optional .vehicle.Image image = 3;
  if (this->has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, *this->image_, output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.VehicleCapture)
}

int VehicleCapture::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.VehicleCapture)
  int total_size = 0;

  // optional fixed64 timestamp = 1;
  if (this->timestamp() != 0) {
    total_size += 1 + 8;
  }

  // optional .vehicle.VehicleInfo vehicle = 2;
  if (this->has_vehicle()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->vehicle_);
  }

  // optional .vehicle.Image image = 3;
  if (this->has_image()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->image_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VehicleCapture::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const VehicleCapture*>(&from));
}

void VehicleCapture::MergeFrom(const VehicleCapture& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.VehicleCapture)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
  if (from.has_vehicle()) {
    mutable_vehicle()->::vehicle::VehicleInfo::MergeFrom(from.vehicle());
  }
  if (from.has_image()) {
    mutable_image()->::vehicle::Image::MergeFrom(from.image());
  }
}

void VehicleCapture::CopyFrom(const VehicleCapture& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.VehicleCapture)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VehicleCapture::IsInitialized() const {

  return true;
}

void VehicleCapture::Swap(VehicleCapture* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VehicleCapture::InternalSwap(VehicleCapture* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(vehicle_, other->vehicle_);
  std::swap(image_, other->image_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string VehicleCapture::GetTypeName() const {
  return "vehicle.VehicleCapture";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VehicleCapture

// optional fixed64 timestamp = 1;
void VehicleCapture::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 VehicleCapture::timestamp() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleCapture.timestamp)
  return timestamp_;
}
 void VehicleCapture::set_timestamp(::google::protobuf::uint64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleCapture.timestamp)
}

// optional .vehicle.VehicleInfo vehicle = 2;
bool VehicleCapture::has_vehicle() const {
  return !_is_default_instance_ && vehicle_ != NULL;
}
void VehicleCapture::clear_vehicle() {
  if (GetArenaNoVirtual() == NULL && vehicle_ != NULL) delete vehicle_;
  vehicle_ = NULL;
}
const ::vehicle::VehicleInfo& VehicleCapture::vehicle() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleCapture.vehicle)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vehicle_ != NULL ? *vehicle_ : *default_instance().vehicle_;
#else
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
#endif
}
::vehicle::VehicleInfo* VehicleCapture::mutable_vehicle() {

  if (vehicle_ == NULL) {
    vehicle_ = new ::vehicle::VehicleInfo;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleCapture.vehicle)
  return vehicle_;
}
::vehicle::VehicleInfo* VehicleCapture::release_vehicle() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleCapture.vehicle)

  ::vehicle::VehicleInfo* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
void VehicleCapture::set_allocated_vehicle(::vehicle::VehicleInfo* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleCapture.vehicle)
}

// optional .vehicle.Image image = 3;
bool VehicleCapture::has_image() const {
  return !_is_default_instance_ && image_ != NULL;
}
void VehicleCapture::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
const ::vehicle::Image& VehicleCapture::image() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleCapture.image)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_ != NULL ? *image_ : *default_instance().image_;
#else
  return image_ != NULL ? *image_ : *default_instance_->image_;
#endif
}
::vehicle::Image* VehicleCapture::mutable_image() {

  if (image_ == NULL) {
    image_ = new ::vehicle::Image;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleCapture.image)
  return image_;
}
::vehicle::Image* VehicleCapture::release_image() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleCapture.image)

  ::vehicle::Image* temp = image_;
  image_ = NULL;
  return temp;
}
void VehicleCapture::set_allocated_image(::vehicle::Image* image) {
  delete image_;
  image_ = image;
  if (image) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleCapture.image)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SmartMessage::kAnomalysFieldNumber;
const int SmartMessage::kCapturesFieldNumber;
const int SmartMessage::kTrafficConditionsFieldNumber;
const int SmartMessage::kTrafficFlowFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SmartMessage::SmartMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.SmartMessage)
}

void SmartMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  traffic_flow_ = const_cast< ::vehicle::TrafficFlow*>(
      ::vehicle::TrafficFlow::internal_default_instance());
#else
  traffic_flow_ = const_cast< ::vehicle::TrafficFlow*>(&::vehicle::TrafficFlow::default_instance());
#endif
}

SmartMessage::SmartMessage(const SmartMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.SmartMessage)
}

void SmartMessage::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  traffic_flow_ = NULL;
}

SmartMessage::~SmartMessage() {
  // @@protoc_insertion_point(destructor:vehicle.SmartMessage)
  SharedDtor();
}

void SmartMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete traffic_flow_;
  }
}

void SmartMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const SmartMessage& SmartMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

SmartMessage* SmartMessage::default_instance_ = NULL;

SmartMessage* SmartMessage::New(::google::protobuf::Arena* arena) const {
  SmartMessage* n = new SmartMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SmartMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.SmartMessage)
  if (GetArenaNoVirtual() == NULL && traffic_flow_ != NULL) delete traffic_flow_;
  traffic_flow_ = NULL;
  anomalys_.Clear();
  captures_.Clear();
  traffic_conditions_.Clear();
}

bool SmartMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.SmartMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .vehicle.Anomaly anomalys = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_anomalys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_anomalys()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_anomalys;
        if (input->ExpectTag(18)) goto parse_loop_captures;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .vehicle.VehicleCapture captures = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_captures:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_captures()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_captures;
        if (input->ExpectTag(26)) goto parse_loop_traffic_conditions;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .vehicle.TrafficCondition traffic_conditions = 3;
      case 3: {
        if (tag == 26) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_traffic_conditions:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_traffic_conditions()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_traffic_conditions;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(34)) goto parse_traffic_flow;
        break;
      }

      // optional .vehicle.TrafficFlow traffic_flow = 4;
      case 4: {
        if (tag == 34) {
         parse_traffic_flow:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_traffic_flow()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.SmartMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.SmartMessage)
  return false;
#undef DO_
}

void SmartMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.SmartMessage)
  // repeated .vehicle.Anomaly anomalys = 1;
  for (unsigned int i = 0, n = this->anomalys_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      1, this->anomalys(i), output);
  }

  // repeated .vehicle.VehicleCapture captures = 2;
  for (unsigned int i = 0, n = this->captures_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->captures(i), output);
  }

  // repeated .vehicle.TrafficCondition traffic_conditions = 3;
  for (unsigned int i = 0, n = this->traffic_conditions_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->traffic_conditions(i), output);
  }

  // optional .vehicle.TrafficFlow traffic_flow = 4;
  if (this->has_traffic_flow()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, *this->traffic_flow_, output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.SmartMessage)
}

int SmartMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.SmartMessage)
  int total_size = 0;

  // optional .vehicle.TrafficFlow traffic_flow = 4;
  if (this->has_traffic_flow()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->traffic_flow_);
  }

  // repeated .vehicle.Anomaly anomalys = 1;
  total_size += 1 * this->anomalys_size();
  for (int i = 0; i < this->anomalys_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->anomalys(i));
  }

  // repeated .vehicle.VehicleCapture captures = 2;
  total_size += 1 * this->captures_size();
  for (int i = 0; i < this->captures_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->captures(i));
  }

  // repeated .vehicle.TrafficCondition traffic_conditions = 3;
  total_size += 1 * this->traffic_conditions_size();
  for (int i = 0; i < this->traffic_conditions_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->traffic_conditions(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SmartMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const SmartMessage*>(&from));
}

void SmartMessage::MergeFrom(const SmartMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.SmartMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  anomalys_.MergeFrom(from.anomalys_);
  captures_.MergeFrom(from.captures_);
  traffic_conditions_.MergeFrom(from.traffic_conditions_);
  if (from.has_traffic_flow()) {
    mutable_traffic_flow()->::vehicle::TrafficFlow::MergeFrom(from.traffic_flow());
  }
}

void SmartMessage::CopyFrom(const SmartMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.SmartMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SmartMessage::IsInitialized() const {

  return true;
}

void SmartMessage::Swap(SmartMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SmartMessage::InternalSwap(SmartMessage* other) {
  anomalys_.UnsafeArenaSwap(&other->anomalys_);
  captures_.UnsafeArenaSwap(&other->captures_);
  traffic_conditions_.UnsafeArenaSwap(&other->traffic_conditions_);
  std::swap(traffic_flow_, other->traffic_flow_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string SmartMessage::GetTypeName() const {
  return "vehicle.SmartMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SmartMessage

// repeated .vehicle.Anomaly anomalys = 1;
int SmartMessage::anomalys_size() const {
  return anomalys_.size();
}
void SmartMessage::clear_anomalys() {
  anomalys_.Clear();
}
const ::vehicle::Anomaly& SmartMessage::anomalys(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.anomalys)
  return anomalys_.Get(index);
}
::vehicle::Anomaly* SmartMessage::mutable_anomalys(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.anomalys)
  return anomalys_.Mutable(index);
}
::vehicle::Anomaly* SmartMessage::add_anomalys() {
  // @@protoc_insertion_point(field_add:vehicle.SmartMessage.anomalys)
  return anomalys_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::Anomaly >*
SmartMessage::mutable_anomalys() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.SmartMessage.anomalys)
  return &anomalys_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::Anomaly >&
SmartMessage::anomalys() const {
  // @@protoc_insertion_point(field_list:vehicle.SmartMessage.anomalys)
  return anomalys_;
}

// repeated .vehicle.VehicleCapture captures = 2;
int SmartMessage::captures_size() const {
  return captures_.size();
}
void SmartMessage::clear_captures() {
  captures_.Clear();
}
const ::vehicle::VehicleCapture& SmartMessage::captures(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.captures)
  return captures_.Get(index);
}
::vehicle::VehicleCapture* SmartMessage::mutable_captures(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.captures)
  return captures_.Mutable(index);
}
::vehicle::VehicleCapture* SmartMessage::add_captures() {
  // @@protoc_insertion_point(field_add:vehicle.SmartMessage.captures)
  return captures_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >*
SmartMessage::mutable_captures() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.SmartMessage.captures)
  return &captures_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >&
SmartMessage::captures() const {
  // @@protoc_insertion_point(field_list:vehicle.SmartMessage.captures)
  return captures_;
}

// repeated .vehicle.TrafficCondition traffic_conditions = 3;
int SmartMessage::traffic_conditions_size() const {
  return traffic_conditions_.size();
}
void SmartMessage::clear_traffic_conditions() {
  traffic_conditions_.Clear();
}
const ::vehicle::TrafficCondition& SmartMessage::traffic_conditions(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_.Get(index);
}
::vehicle::TrafficCondition* SmartMessage::mutable_traffic_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_.Mutable(index);
}
::vehicle::TrafficCondition* SmartMessage::add_traffic_conditions() {
  // @@protoc_insertion_point(field_add:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::TrafficCondition >*
SmartMessage::mutable_traffic_conditions() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.SmartMessage.traffic_conditions)
  return &traffic_conditions_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::TrafficCondition >&
SmartMessage::traffic_conditions() const {
  // @@protoc_insertion_point(field_list:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_;
}

// optional .vehicle.TrafficFlow traffic_flow = 4;
bool SmartMessage::has_traffic_flow() const {
  return !_is_default_instance_ && traffic_flow_ != NULL;
}
void SmartMessage::clear_traffic_flow() {
  if (GetArenaNoVirtual() == NULL && traffic_flow_ != NULL) delete traffic_flow_;
  traffic_flow_ = NULL;
}
const ::vehicle::TrafficFlow& SmartMessage::traffic_flow() const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.traffic_flow)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return traffic_flow_ != NULL ? *traffic_flow_ : *default_instance().traffic_flow_;
#else
  return traffic_flow_ != NULL ? *traffic_flow_ : *default_instance_->traffic_flow_;
#endif
}
::vehicle::TrafficFlow* SmartMessage::mutable_traffic_flow() {

  if (traffic_flow_ == NULL) {
    traffic_flow_ = new ::vehicle::TrafficFlow;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.traffic_flow)
  return traffic_flow_;
}
::vehicle::TrafficFlow* SmartMessage::release_traffic_flow() {
  // @@protoc_insertion_point(field_release:vehicle.SmartMessage.traffic_flow)

  ::vehicle::TrafficFlow* temp = traffic_flow_;
  traffic_flow_ = NULL;
  return temp;
}
void SmartMessage::set_allocated_traffic_flow(::vehicle::TrafficFlow* traffic_flow) {
  delete traffic_flow_;
  traffic_flow_ = traffic_flow;
  if (traffic_flow) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.SmartMessage.traffic_flow)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FrameMessage::kTimestampFieldNumber;
const int FrameMessage::kVehiclesFieldNumber;
const int FrameMessage::kNonmotorsFieldNumber;
const int FrameMessage::kPersonsFieldNumber;
const int FrameMessage::kSmartMsgFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FrameMessage::FrameMessage()
  : ::google::protobuf::MessageLite(), _arena_ptr_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:vehicle.FrameMessage)
}

void FrameMessage::InitAsDefaultInstance() {
  _is_default_instance_ = true;
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  smart_msg_ = const_cast< ::vehicle::SmartMessage*>(
      ::vehicle::SmartMessage::internal_default_instance());
#else
  smart_msg_ = const_cast< ::vehicle::SmartMessage*>(&::vehicle::SmartMessage::default_instance());
#endif
}

FrameMessage::FrameMessage(const FrameMessage& from)
  : ::google::protobuf::MessageLite(),
    _arena_ptr_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:vehicle.FrameMessage)
}

void FrameMessage::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  timestamp_ = GOOGLE_ULONGLONG(0);
  smart_msg_ = NULL;
}

FrameMessage::~FrameMessage() {
  // @@protoc_insertion_point(destructor:vehicle.FrameMessage)
  SharedDtor();
}

void FrameMessage::SharedDtor() {
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  if (this != &default_instance()) {
  #else
  if (this != default_instance_) {
  #endif
    delete smart_msg_;
  }
}

void FrameMessage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const FrameMessage& FrameMessage::default_instance() {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  protobuf_AddDesc_vehicle_2eproto();
#else
  if (default_instance_ == NULL) protobuf_AddDesc_vehicle_2eproto();
#endif
  return *default_instance_;
}

FrameMessage* FrameMessage::default_instance_ = NULL;

FrameMessage* FrameMessage::New(::google::protobuf::Arena* arena) const {
  FrameMessage* n = new FrameMessage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FrameMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:vehicle.FrameMessage)
  timestamp_ = GOOGLE_ULONGLONG(0);
  if (GetArenaNoVirtual() == NULL && smart_msg_ != NULL) delete smart_msg_;
  smart_msg_ = NULL;
  vehicles_.Clear();
  nonmotors_.Clear();
  persons_.Clear();
}

bool FrameMessage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:vehicle.FrameMessage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &timestamp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_vehicles;
        break;
      }

      // repeated .vehicle.VehicleInfo vehicles = 2;
      case 2: {
        if (tag == 18) {
         parse_vehicles:
          DO_(input->IncrementRecursionDepth());
         parse_loop_vehicles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_vehicles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_vehicles;
        if (input->ExpectTag(26)) goto parse_loop_nonmotors;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .vehicle.Nonmotor nonmotors = 3;
      case 3: {
        if (tag == 26) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_nonmotors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_nonmotors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_nonmotors;
        if (input->ExpectTag(34)) goto parse_loop_persons;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .vehicle.Person persons = 4;
      case 4: {
        if (tag == 34) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_persons:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_persons()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_persons;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(42)) goto parse_smart_msg;
        break;
      }

      // optional .vehicle.SmartMessage smart_msg = 5;
      case 5: {
        if (tag == 42) {
         parse_smart_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_smart_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:vehicle.FrameMessage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:vehicle.FrameMessage)
  return false;
#undef DO_
}

void FrameMessage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:vehicle.FrameMessage)
  // optional fixed64 timestamp = 1;
  if (this->timestamp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->timestamp(), output);
  }

  // repeated .vehicle.VehicleInfo vehicles = 2;
  for (unsigned int i = 0, n = this->vehicles_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      2, this->vehicles(i), output);
  }

  // repeated .vehicle.Nonmotor nonmotors = 3;
  for (unsigned int i = 0, n = this->nonmotors_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      3, this->nonmotors(i), output);
  }

  // repeated .vehicle.Person persons = 4;
  for (unsigned int i = 0, n = this->persons_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      4, this->persons(i), output);
  }

  // optional .vehicle.SmartMessage smart_msg = 5;
  if (this->has_smart_msg()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessage(
      5, *this->smart_msg_, output);
  }

  // @@protoc_insertion_point(serialize_end:vehicle.FrameMessage)
}

int FrameMessage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:vehicle.FrameMessage)
  int total_size = 0;

  // optional fixed64 timestamp = 1;
  if (this->timestamp() != 0) {
    total_size += 1 + 8;
  }

  // optional .vehicle.SmartMessage smart_msg = 5;
  if (this->has_smart_msg()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->smart_msg_);
  }

  // repeated .vehicle.VehicleInfo vehicles = 2;
  total_size += 1 * this->vehicles_size();
  for (int i = 0; i < this->vehicles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vehicles(i));
  }

  // repeated .vehicle.Nonmotor nonmotors = 3;
  total_size += 1 * this->nonmotors_size();
  for (int i = 0; i < this->nonmotors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nonmotors(i));
  }

  // repeated .vehicle.Person persons = 4;
  total_size += 1 * this->persons_size();
  for (int i = 0; i < this->persons_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->persons(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameMessage::CheckTypeAndMergeFrom(
    const ::google::protobuf::MessageLite& from) {
  MergeFrom(*::google::protobuf::down_cast<const FrameMessage*>(&from));
}

void FrameMessage::MergeFrom(const FrameMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:vehicle.FrameMessage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  vehicles_.MergeFrom(from.vehicles_);
  nonmotors_.MergeFrom(from.nonmotors_);
  persons_.MergeFrom(from.persons_);
  if (from.timestamp() != 0) {
    set_timestamp(from.timestamp());
  }
  if (from.has_smart_msg()) {
    mutable_smart_msg()->::vehicle::SmartMessage::MergeFrom(from.smart_msg());
  }
}

void FrameMessage::CopyFrom(const FrameMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:vehicle.FrameMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameMessage::IsInitialized() const {

  return true;
}

void FrameMessage::Swap(FrameMessage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FrameMessage::InternalSwap(FrameMessage* other) {
  std::swap(timestamp_, other->timestamp_);
  vehicles_.UnsafeArenaSwap(&other->vehicles_);
  nonmotors_.UnsafeArenaSwap(&other->nonmotors_);
  persons_.UnsafeArenaSwap(&other->persons_);
  std::swap(smart_msg_, other->smart_msg_);
  _unknown_fields_.Swap(&other->_unknown_fields_);
  std::swap(_cached_size_, other->_cached_size_);
}

::std::string FrameMessage::GetTypeName() const {
  return "vehicle.FrameMessage";
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FrameMessage

// optional fixed64 timestamp = 1;
void FrameMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
 ::google::protobuf::uint64 FrameMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.timestamp)
  return timestamp_;
}
 void FrameMessage::set_timestamp(::google::protobuf::uint64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vehicle.FrameMessage.timestamp)
}

// repeated .vehicle.VehicleInfo vehicles = 2;
int FrameMessage::vehicles_size() const {
  return vehicles_.size();
}
void FrameMessage::clear_vehicles() {
  vehicles_.Clear();
}
const ::vehicle::VehicleInfo& FrameMessage::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.vehicles)
  return vehicles_.Get(index);
}
::vehicle::VehicleInfo* FrameMessage::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.vehicles)
  return vehicles_.Mutable(index);
}
::vehicle::VehicleInfo* FrameMessage::add_vehicles() {
  // @@protoc_insertion_point(field_add:vehicle.FrameMessage.vehicles)
  return vehicles_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::VehicleInfo >*
FrameMessage::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.FrameMessage.vehicles)
  return &vehicles_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleInfo >&
FrameMessage::vehicles() const {
  // @@protoc_insertion_point(field_list:vehicle.FrameMessage.vehicles)
  return vehicles_;
}

// repeated .vehicle.Nonmotor nonmotors = 3;
int FrameMessage::nonmotors_size() const {
  return nonmotors_.size();
}
void FrameMessage::clear_nonmotors() {
  nonmotors_.Clear();
}
const ::vehicle::Nonmotor& FrameMessage::nonmotors(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.nonmotors)
  return nonmotors_.Get(index);
}
::vehicle::Nonmotor* FrameMessage::mutable_nonmotors(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.nonmotors)
  return nonmotors_.Mutable(index);
}
::vehicle::Nonmotor* FrameMessage::add_nonmotors() {
  // @@protoc_insertion_point(field_add:vehicle.FrameMessage.nonmotors)
  return nonmotors_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::Nonmotor >*
FrameMessage::mutable_nonmotors() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.FrameMessage.nonmotors)
  return &nonmotors_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::Nonmotor >&
FrameMessage::nonmotors() const {
  // @@protoc_insertion_point(field_list:vehicle.FrameMessage.nonmotors)
  return nonmotors_;
}

// repeated .vehicle.Person persons = 4;
int FrameMessage::persons_size() const {
  return persons_.size();
}
void FrameMessage::clear_persons() {
  persons_.Clear();
}
const ::vehicle::Person& FrameMessage::persons(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.persons)
  return persons_.Get(index);
}
::vehicle::Person* FrameMessage::mutable_persons(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.persons)
  return persons_.Mutable(index);
}
::vehicle::Person* FrameMessage::add_persons() {
  // @@protoc_insertion_point(field_add:vehicle.FrameMessage.persons)
  return persons_.Add();
}
::google::protobuf::RepeatedPtrField< ::vehicle::Person >*
FrameMessage::mutable_persons() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.FrameMessage.persons)
  return &persons_;
}
const ::google::protobuf::RepeatedPtrField< ::vehicle::Person >&
FrameMessage::persons() const {
  // @@protoc_insertion_point(field_list:vehicle.FrameMessage.persons)
  return persons_;
}

// optional .vehicle.SmartMessage smart_msg = 5;
bool FrameMessage::has_smart_msg() const {
  return !_is_default_instance_ && smart_msg_ != NULL;
}
void FrameMessage::clear_smart_msg() {
  if (GetArenaNoVirtual() == NULL && smart_msg_ != NULL) delete smart_msg_;
  smart_msg_ = NULL;
}
const ::vehicle::SmartMessage& FrameMessage::smart_msg() const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.smart_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return smart_msg_ != NULL ? *smart_msg_ : *default_instance().smart_msg_;
#else
  return smart_msg_ != NULL ? *smart_msg_ : *default_instance_->smart_msg_;
#endif
}
::vehicle::SmartMessage* FrameMessage::mutable_smart_msg() {

  if (smart_msg_ == NULL) {
    smart_msg_ = new ::vehicle::SmartMessage;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.smart_msg)
  return smart_msg_;
}
::vehicle::SmartMessage* FrameMessage::release_smart_msg() {
  // @@protoc_insertion_point(field_release:vehicle.FrameMessage.smart_msg)

  ::vehicle::SmartMessage* temp = smart_msg_;
  smart_msg_ = NULL;
  return temp;
}
void FrameMessage::set_allocated_smart_msg(::vehicle::SmartMessage* smart_msg) {
  delete smart_msg_;
  smart_msg_ = smart_msg;
  if (smart_msg) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.FrameMessage.smart_msg)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace vehicle

// @@protoc_insertion_point(global_scope)
