// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vehicle.proto

#ifndef PROTOBUF_vehicle_2eproto__INCLUDED
#define PROTOBUF_vehicle_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace vehicle {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_vehicle_2eproto();
void protobuf_AssignDesc_vehicle_2eproto();
void protobuf_ShutdownFile_vehicle_2eproto();

class Anomaly;
class Box;
class FrameMessage;
class Gis;
class Image;
class Nonmotor;
class Person;
class Plate;
class Point;
class Points;
class SmartMessage;
class TrafficCondition;
class TrafficFlow;
class VehicleCapture;
class VehicleInfo;

// ===================================================================

class Point : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  static const Point& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Point* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  inline Point* New() const { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float score = 3;
  void clear_score();
  static const int kScoreFieldNumber = 3;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:vehicle.Point)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  float x_;
  float y_;
  float score_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class Points : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Points) */ {
 public:
  Points();
  virtual ~Points();

  Points(const Points& from);

  inline Points& operator=(const Points& from) {
    CopyFrom(from);
    return *this;
  }

  static const Points& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Points* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Points* other);

  // implements Message ----------------------------------------------

  inline Points* New() const { return New(NULL); }

  Points* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Points& from);
  void MergeFrom(const Points& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Points* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // repeated .vehicle.Point points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  const ::vehicle::Point& points(int index) const;
  ::vehicle::Point* mutable_points(int index);
  ::vehicle::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::vehicle::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::Point >&
      points() const;

  // @@protoc_insertion_point(class_scope:vehicle.Points)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::Point > points_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Points* default_instance_;
};
// -------------------------------------------------------------------

class Box : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Box) */ {
 public:
  Box();
  virtual ~Box();

  Box(const Box& from);

  inline Box& operator=(const Box& from) {
    CopyFrom(from);
    return *this;
  }

  static const Box& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Box* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Box* other);

  // implements Message ----------------------------------------------

  inline Box* New() const { return New(NULL); }

  Box* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Box& from);
  void MergeFrom(const Box& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Box* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional .vehicle.Point top_left = 2;
  bool has_top_left() const;
  void clear_top_left();
  static const int kTopLeftFieldNumber = 2;
  const ::vehicle::Point& top_left() const;
  ::vehicle::Point* mutable_top_left();
  ::vehicle::Point* release_top_left();
  void set_allocated_top_left(::vehicle::Point* top_left);

  // optional .vehicle.Point bottom_right = 3;
  bool has_bottom_right() const;
  void clear_bottom_right();
  static const int kBottomRightFieldNumber = 3;
  const ::vehicle::Point& bottom_right() const;
  ::vehicle::Point* mutable_bottom_right();
  ::vehicle::Point* release_bottom_right();
  void set_allocated_bottom_right(::vehicle::Point* bottom_right);

  // optional float score = 4;
  void clear_score();
  static const int kScoreFieldNumber = 4;
  float score() const;
  void set_score(float value);

  // @@protoc_insertion_point(class_scope:vehicle.Box)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::vehicle::Point* top_left_;
  ::vehicle::Point* bottom_right_;
  float score_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Box* default_instance_;
};
// -------------------------------------------------------------------

class Image : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Image) */ {
 public:
  Image();
  virtual ~Image();

  Image(const Image& from);

  inline Image& operator=(const Image& from) {
    CopyFrom(from);
    return *this;
  }

  static const Image& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Image* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Image* other);

  // implements Message ----------------------------------------------

  inline Image* New() const { return New(NULL); }

  Image* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Image& from);
  void MergeFrom(const Image& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Image* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes buf = 1;
  void clear_buf();
  static const int kBufFieldNumber = 1;
  const ::std::string& buf() const;
  void set_buf(const ::std::string& value);
  void set_buf(const char* value);
  void set_buf(const void* value, size_t size);
  ::std::string* mutable_buf();
  ::std::string* release_buf();
  void set_allocated_buf(::std::string* buf);

  // optional string type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::std::string& type() const;
  void set_type(const ::std::string& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  ::std::string* mutable_type();
  ::std::string* release_type();
  void set_allocated_type(::std::string* type);

  // optional uint32 width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional uint32 height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  ::google::protobuf::uint32 height() const;
  void set_height(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:vehicle.Image)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr buf_;
  ::google::protobuf::internal::ArenaStringPtr type_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 height_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Image* default_instance_;
};
// -------------------------------------------------------------------

class Plate : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Plate) */ {
 public:
  Plate();
  virtual ~Plate();

  Plate(const Plate& from);

  inline Plate& operator=(const Plate& from) {
    CopyFrom(from);
    return *this;
  }

  static const Plate& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Plate* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Plate* other);

  // implements Message ----------------------------------------------

  inline Plate* New() const { return New(NULL); }

  Plate* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Plate& from);
  void MergeFrom(const Plate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Plate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .vehicle.Box box = 1;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 1;
  const ::vehicle::Box& box() const;
  ::vehicle::Box* mutable_box();
  ::vehicle::Box* release_box();
  void set_allocated_box(::vehicle::Box* box);

  // optional bool is_double_plate = 2;
  void clear_is_double_plate();
  static const int kIsDoublePlateFieldNumber = 2;
  bool is_double_plate() const;
  void set_is_double_plate(bool value);

  // optional .vehicle.Points points = 3;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  const ::vehicle::Points& points() const;
  ::vehicle::Points* mutable_points();
  ::vehicle::Points* release_points();
  void set_allocated_points(::vehicle::Points* points);

  // optional bytes plate_num = 4;
  void clear_plate_num();
  static const int kPlateNumFieldNumber = 4;
  const ::std::string& plate_num() const;
  void set_plate_num(const ::std::string& value);
  void set_plate_num(const char* value);
  void set_plate_num(const void* value, size_t size);
  ::std::string* mutable_plate_num();
  ::std::string* release_plate_num();
  void set_allocated_plate_num(::std::string* plate_num);

  // optional int32 color = 5;
  void clear_color();
  static const int kColorFieldNumber = 5;
  ::google::protobuf::int32 color() const;
  void set_color(::google::protobuf::int32 value);

  // optional int32 type = 6;
  void clear_type();
  static const int kTypeFieldNumber = 6;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:vehicle.Plate)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::vehicle::Box* box_;
  ::vehicle::Points* points_;
  bool is_double_plate_;
  ::google::protobuf::int32 color_;
  ::google::protobuf::internal::ArenaStringPtr plate_num_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Plate* default_instance_;
};
// -------------------------------------------------------------------

class Gis : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Gis) */ {
 public:
  Gis();
  virtual ~Gis();

  Gis(const Gis& from);

  inline Gis& operator=(const Gis& from) {
    CopyFrom(from);
    return *this;
  }

  static const Gis& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Gis* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Gis* other);

  // implements Message ----------------------------------------------

  inline Gis* New() const { return New(NULL); }

  Gis* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Gis& from);
  void MergeFrom(const Gis& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Gis* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float longitude = 1;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 1;
  float longitude() const;
  void set_longitude(float value);

  // optional float latitude = 2;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 2;
  float latitude() const;
  void set_latitude(float value);

  // optional float width = 3;
  void clear_width();
  static const int kWidthFieldNumber = 3;
  float width() const;
  void set_width(float value);

  // optional float height = 4;
  void clear_height();
  static const int kHeightFieldNumber = 4;
  float height() const;
  void set_height(float value);

  // optional float orientation = 5;
  void clear_orientation();
  static const int kOrientationFieldNumber = 5;
  float orientation() const;
  void set_orientation(float value);

  // @@protoc_insertion_point(class_scope:vehicle.Gis)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  float longitude_;
  float latitude_;
  float width_;
  float height_;
  float orientation_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Gis* default_instance_;
};
// -------------------------------------------------------------------

class VehicleInfo : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.VehicleInfo) */ {
 public:
  VehicleInfo();
  virtual ~VehicleInfo();

  VehicleInfo(const VehicleInfo& from);

  inline VehicleInfo& operator=(const VehicleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const VehicleInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VehicleInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VehicleInfo* other);

  // implements Message ----------------------------------------------

  inline VehicleInfo* New() const { return New(NULL); }

  VehicleInfo* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VehicleInfo& from);
  void MergeFrom(const VehicleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 track_id = 1;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 1;
  ::google::protobuf::uint64 track_id() const;
  void set_track_id(::google::protobuf::uint64 value);

  // optional int32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // optional int32 color = 3;
  void clear_color();
  static const int kColorFieldNumber = 3;
  ::google::protobuf::int32 color() const;
  void set_color(::google::protobuf::int32 value);

  // optional .vehicle.Box box = 4;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 4;
  const ::vehicle::Box& box() const;
  ::vehicle::Box* mutable_box();
  ::vehicle::Box* release_box();
  void set_allocated_box(::vehicle::Box* box);

  // optional .vehicle.Points points = 5;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 5;
  const ::vehicle::Points& points() const;
  ::vehicle::Points* mutable_points();
  ::vehicle::Points* release_points();
  void set_allocated_points(::vehicle::Points* points);

  // optional .vehicle.Plate plate_info = 6;
  bool has_plate_info() const;
  void clear_plate_info();
  static const int kPlateInfoFieldNumber = 6;
  const ::vehicle::Plate& plate_info() const;
  ::vehicle::Plate* mutable_plate_info();
  ::vehicle::Plate* release_plate_info();
  void set_allocated_plate_info(::vehicle::Plate* plate_info);

  // optional .vehicle.Point location = 7;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 7;
  const ::vehicle::Point& location() const;
  ::vehicle::Point* mutable_location();
  ::vehicle::Point* release_location();
  void set_allocated_location(::vehicle::Point* location);

  // optional uint32 lane_id = 8;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 8;
  ::google::protobuf::uint32 lane_id() const;
  void set_lane_id(::google::protobuf::uint32 value);

  // optional float speed = 9;
  void clear_speed();
  static const int kSpeedFieldNumber = 9;
  float speed() const;
  void set_speed(float value);

  // optional .vehicle.Gis gis_info = 10;
  bool has_gis_info() const;
  void clear_gis_info();
  static const int kGisInfoFieldNumber = 10;
  const ::vehicle::Gis& gis_info() const;
  ::vehicle::Gis* mutable_gis_info();
  ::vehicle::Gis* release_gis_info();
  void set_allocated_gis_info(::vehicle::Gis* gis_info);

  // @@protoc_insertion_point(class_scope:vehicle.VehicleInfo)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::uint64 track_id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 color_;
  ::vehicle::Box* box_;
  ::vehicle::Points* points_;
  ::vehicle::Plate* plate_info_;
  ::vehicle::Point* location_;
  ::google::protobuf::uint32 lane_id_;
  float speed_;
  ::vehicle::Gis* gis_info_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static VehicleInfo* default_instance_;
};
// -------------------------------------------------------------------

class Nonmotor : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Nonmotor) */ {
 public:
  Nonmotor();
  virtual ~Nonmotor();

  Nonmotor(const Nonmotor& from);

  inline Nonmotor& operator=(const Nonmotor& from) {
    CopyFrom(from);
    return *this;
  }

  static const Nonmotor& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Nonmotor* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Nonmotor* other);

  // implements Message ----------------------------------------------

  inline Nonmotor* New() const { return New(NULL); }

  Nonmotor* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Nonmotor& from);
  void MergeFrom(const Nonmotor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Nonmotor* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 track_id = 1;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 1;
  ::google::protobuf::uint64 track_id() const;
  void set_track_id(::google::protobuf::uint64 value);

  // optional .vehicle.Box box = 2;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 2;
  const ::vehicle::Box& box() const;
  ::vehicle::Box* mutable_box();
  ::vehicle::Box* release_box();
  void set_allocated_box(::vehicle::Box* box);

  // optional .vehicle.Points points = 3;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  const ::vehicle::Points& points() const;
  ::vehicle::Points* mutable_points();
  ::vehicle::Points* release_points();
  void set_allocated_points(::vehicle::Points* points);

  // optional .vehicle.Point location = 4;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::vehicle::Point& location() const;
  ::vehicle::Point* mutable_location();
  ::vehicle::Point* release_location();
  void set_allocated_location(::vehicle::Point* location);

  // optional uint32 lane_id = 5;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 5;
  ::google::protobuf::uint32 lane_id() const;
  void set_lane_id(::google::protobuf::uint32 value);

  // optional float speed = 6;
  void clear_speed();
  static const int kSpeedFieldNumber = 6;
  float speed() const;
  void set_speed(float value);

  // optional .vehicle.Gis gis_info = 7;
  bool has_gis_info() const;
  void clear_gis_info();
  static const int kGisInfoFieldNumber = 7;
  const ::vehicle::Gis& gis_info() const;
  ::vehicle::Gis* mutable_gis_info();
  ::vehicle::Gis* release_gis_info();
  void set_allocated_gis_info(::vehicle::Gis* gis_info);

  // @@protoc_insertion_point(class_scope:vehicle.Nonmotor)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::uint64 track_id_;
  ::vehicle::Box* box_;
  ::vehicle::Points* points_;
  ::vehicle::Point* location_;
  ::google::protobuf::uint32 lane_id_;
  float speed_;
  ::vehicle::Gis* gis_info_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Nonmotor* default_instance_;
};
// -------------------------------------------------------------------

class Person : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Person) */ {
 public:
  Person();
  virtual ~Person();

  Person(const Person& from);

  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }

  static const Person& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Person* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Person* other);

  // implements Message ----------------------------------------------

  inline Person* New() const { return New(NULL); }

  Person* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Person& from);
  void MergeFrom(const Person& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Person* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 track_id = 1;
  void clear_track_id();
  static const int kTrackIdFieldNumber = 1;
  ::google::protobuf::uint64 track_id() const;
  void set_track_id(::google::protobuf::uint64 value);

  // optional .vehicle.Box box = 2;
  bool has_box() const;
  void clear_box();
  static const int kBoxFieldNumber = 2;
  const ::vehicle::Box& box() const;
  ::vehicle::Box* mutable_box();
  ::vehicle::Box* release_box();
  void set_allocated_box(::vehicle::Box* box);

  // optional .vehicle.Points points = 3;
  bool has_points() const;
  void clear_points();
  static const int kPointsFieldNumber = 3;
  const ::vehicle::Points& points() const;
  ::vehicle::Points* mutable_points();
  ::vehicle::Points* release_points();
  void set_allocated_points(::vehicle::Points* points);

  // optional .vehicle.Point location = 4;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 4;
  const ::vehicle::Point& location() const;
  ::vehicle::Point* mutable_location();
  ::vehicle::Point* release_location();
  void set_allocated_location(::vehicle::Point* location);

  // optional uint32 lane_id = 5;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 5;
  ::google::protobuf::uint32 lane_id() const;
  void set_lane_id(::google::protobuf::uint32 value);

  // optional float speed = 6;
  void clear_speed();
  static const int kSpeedFieldNumber = 6;
  float speed() const;
  void set_speed(float value);

  // optional .vehicle.Gis gis_info = 7;
  bool has_gis_info() const;
  void clear_gis_info();
  static const int kGisInfoFieldNumber = 7;
  const ::vehicle::Gis& gis_info() const;
  ::vehicle::Gis* mutable_gis_info();
  ::vehicle::Gis* release_gis_info();
  void set_allocated_gis_info(::vehicle::Gis* gis_info);

  // @@protoc_insertion_point(class_scope:vehicle.Person)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::uint64 track_id_;
  ::vehicle::Box* box_;
  ::vehicle::Points* points_;
  ::vehicle::Point* location_;
  ::google::protobuf::uint32 lane_id_;
  float speed_;
  ::vehicle::Gis* gis_info_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Person* default_instance_;
};
// -------------------------------------------------------------------

class TrafficCondition : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.TrafficCondition) */ {
 public:
  TrafficCondition();
  virtual ~TrafficCondition();

  TrafficCondition(const TrafficCondition& from);

  inline TrafficCondition& operator=(const TrafficCondition& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficCondition& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficCondition* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficCondition* other);

  // implements Message ----------------------------------------------

  inline TrafficCondition* New() const { return New(NULL); }

  TrafficCondition* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficCondition& from);
  void MergeFrom(const TrafficCondition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrafficCondition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional uint32 type = 2;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // optional float value = 3;
  void clear_value();
  static const int kValueFieldNumber = 3;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:vehicle.TrafficCondition)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint32 type_;
  float value_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static TrafficCondition* default_instance_;
};
// -------------------------------------------------------------------

class TrafficFlow : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.TrafficFlow) */ {
 public:
  TrafficFlow();
  virtual ~TrafficFlow();

  TrafficFlow(const TrafficFlow& from);

  inline TrafficFlow& operator=(const TrafficFlow& from) {
    CopyFrom(from);
    return *this;
  }

  static const TrafficFlow& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TrafficFlow* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TrafficFlow* other);

  // implements Message ----------------------------------------------

  inline TrafficFlow* New() const { return New(NULL); }

  TrafficFlow* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TrafficFlow& from);
  void MergeFrom(const TrafficFlow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TrafficFlow* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 hour_index = 1;
  void clear_hour_index();
  static const int kHourIndexFieldNumber = 1;
  ::google::protobuf::uint32 hour_index() const;
  void set_hour_index(::google::protobuf::uint32 value);

  // optional uint32 cycle_count = 2;
  void clear_cycle_count();
  static const int kCycleCountFieldNumber = 2;
  ::google::protobuf::uint32 cycle_count() const;
  void set_cycle_count(::google::protobuf::uint32 value);

  // optional uint32 cycle_minute = 3;
  void clear_cycle_minute();
  static const int kCycleMinuteFieldNumber = 3;
  ::google::protobuf::uint32 cycle_minute() const;
  void set_cycle_minute(::google::protobuf::uint32 value);

  // optional uint32 vehicle_sum = 4;
  void clear_vehicle_sum();
  static const int kVehicleSumFieldNumber = 4;
  ::google::protobuf::uint32 vehicle_sum() const;
  void set_vehicle_sum(::google::protobuf::uint32 value);

  // optional uint32 big_vehicle_sum = 5;
  void clear_big_vehicle_sum();
  static const int kBigVehicleSumFieldNumber = 5;
  ::google::protobuf::uint32 big_vehicle_sum() const;
  void set_big_vehicle_sum(::google::protobuf::uint32 value);

  // optional uint32 small_vehicle_sum = 6;
  void clear_small_vehicle_sum();
  static const int kSmallVehicleSumFieldNumber = 6;
  ::google::protobuf::uint32 small_vehicle_sum() const;
  void set_small_vehicle_sum(::google::protobuf::uint32 value);

  // optional float mean_speed = 7;
  void clear_mean_speed();
  static const int kMeanSpeedFieldNumber = 7;
  float mean_speed() const;
  void set_mean_speed(float value);

  // @@protoc_insertion_point(class_scope:vehicle.TrafficFlow)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::uint32 hour_index_;
  ::google::protobuf::uint32 cycle_count_;
  ::google::protobuf::uint32 cycle_minute_;
  ::google::protobuf::uint32 vehicle_sum_;
  ::google::protobuf::uint32 big_vehicle_sum_;
  ::google::protobuf::uint32 small_vehicle_sum_;
  float mean_speed_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static TrafficFlow* default_instance_;
};
// -------------------------------------------------------------------

class Anomaly : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.Anomaly) */ {
 public:
  Anomaly();
  virtual ~Anomaly();

  Anomaly(const Anomaly& from);

  inline Anomaly& operator=(const Anomaly& from) {
    CopyFrom(from);
    return *this;
  }

  static const Anomaly& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Anomaly* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Anomaly* other);

  // implements Message ----------------------------------------------

  inline Anomaly* New() const { return New(NULL); }

  Anomaly* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Anomaly& from);
  void MergeFrom(const Anomaly& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Anomaly* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::int32 type() const;
  void set_type(::google::protobuf::int32 value);

  // repeated .vehicle.VehicleCapture vehicle_captures = 2;
  int vehicle_captures_size() const;
  void clear_vehicle_captures();
  static const int kVehicleCapturesFieldNumber = 2;
  const ::vehicle::VehicleCapture& vehicle_captures(int index) const;
  ::vehicle::VehicleCapture* mutable_vehicle_captures(int index);
  ::vehicle::VehicleCapture* add_vehicle_captures();
  ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >*
      mutable_vehicle_captures();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >&
      vehicle_captures() const;

  // @@protoc_insertion_point(class_scope:vehicle.Anomaly)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture > vehicle_captures_;
  ::google::protobuf::int32 type_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static Anomaly* default_instance_;
};
// -------------------------------------------------------------------

class VehicleCapture : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.VehicleCapture) */ {
 public:
  VehicleCapture();
  virtual ~VehicleCapture();

  VehicleCapture(const VehicleCapture& from);

  inline VehicleCapture& operator=(const VehicleCapture& from) {
    CopyFrom(from);
    return *this;
  }

  static const VehicleCapture& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const VehicleCapture* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(VehicleCapture* other);

  // implements Message ----------------------------------------------

  inline VehicleCapture* New() const { return New(NULL); }

  VehicleCapture* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const VehicleCapture& from);
  void MergeFrom(const VehicleCapture& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VehicleCapture* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // optional .vehicle.VehicleInfo vehicle = 2;
  bool has_vehicle() const;
  void clear_vehicle();
  static const int kVehicleFieldNumber = 2;
  const ::vehicle::VehicleInfo& vehicle() const;
  ::vehicle::VehicleInfo* mutable_vehicle();
  ::vehicle::VehicleInfo* release_vehicle();
  void set_allocated_vehicle(::vehicle::VehicleInfo* vehicle);

  // optional .vehicle.Image image = 3;
  bool has_image() const;
  void clear_image();
  static const int kImageFieldNumber = 3;
  const ::vehicle::Image& image() const;
  ::vehicle::Image* mutable_image();
  ::vehicle::Image* release_image();
  void set_allocated_image(::vehicle::Image* image);

  // @@protoc_insertion_point(class_scope:vehicle.VehicleCapture)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::uint64 timestamp_;
  ::vehicle::VehicleInfo* vehicle_;
  ::vehicle::Image* image_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static VehicleCapture* default_instance_;
};
// -------------------------------------------------------------------

class SmartMessage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.SmartMessage) */ {
 public:
  SmartMessage();
  virtual ~SmartMessage();

  SmartMessage(const SmartMessage& from);

  inline SmartMessage& operator=(const SmartMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const SmartMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SmartMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SmartMessage* other);

  // implements Message ----------------------------------------------

  inline SmartMessage* New() const { return New(NULL); }

  SmartMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SmartMessage& from);
  void MergeFrom(const SmartMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SmartMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .vehicle.Anomaly anomalys = 1;
  int anomalys_size() const;
  void clear_anomalys();
  static const int kAnomalysFieldNumber = 1;
  const ::vehicle::Anomaly& anomalys(int index) const;
  ::vehicle::Anomaly* mutable_anomalys(int index);
  ::vehicle::Anomaly* add_anomalys();
  ::google::protobuf::RepeatedPtrField< ::vehicle::Anomaly >*
      mutable_anomalys();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::Anomaly >&
      anomalys() const;

  // repeated .vehicle.VehicleCapture captures = 2;
  int captures_size() const;
  void clear_captures();
  static const int kCapturesFieldNumber = 2;
  const ::vehicle::VehicleCapture& captures(int index) const;
  ::vehicle::VehicleCapture* mutable_captures(int index);
  ::vehicle::VehicleCapture* add_captures();
  ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >*
      mutable_captures();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >&
      captures() const;

  // repeated .vehicle.TrafficCondition traffic_conditions = 3;
  int traffic_conditions_size() const;
  void clear_traffic_conditions();
  static const int kTrafficConditionsFieldNumber = 3;
  const ::vehicle::TrafficCondition& traffic_conditions(int index) const;
  ::vehicle::TrafficCondition* mutable_traffic_conditions(int index);
  ::vehicle::TrafficCondition* add_traffic_conditions();
  ::google::protobuf::RepeatedPtrField< ::vehicle::TrafficCondition >*
      mutable_traffic_conditions();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::TrafficCondition >&
      traffic_conditions() const;

  // optional .vehicle.TrafficFlow traffic_flow = 4;
  bool has_traffic_flow() const;
  void clear_traffic_flow();
  static const int kTrafficFlowFieldNumber = 4;
  const ::vehicle::TrafficFlow& traffic_flow() const;
  ::vehicle::TrafficFlow* mutable_traffic_flow();
  ::vehicle::TrafficFlow* release_traffic_flow();
  void set_allocated_traffic_flow(::vehicle::TrafficFlow* traffic_flow);

  // @@protoc_insertion_point(class_scope:vehicle.SmartMessage)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::Anomaly > anomalys_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture > captures_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::TrafficCondition > traffic_conditions_;
  ::vehicle::TrafficFlow* traffic_flow_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static SmartMessage* default_instance_;
};
// -------------------------------------------------------------------

class FrameMessage : public ::google::protobuf::MessageLite /* @@protoc_insertion_point(class_definition:vehicle.FrameMessage) */ {
 public:
  FrameMessage();
  virtual ~FrameMessage();

  FrameMessage(const FrameMessage& from);

  inline FrameMessage& operator=(const FrameMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const FrameMessage& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const FrameMessage* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(FrameMessage* other);

  // implements Message ----------------------------------------------

  inline FrameMessage* New() const { return New(NULL); }

  FrameMessage* New(::google::protobuf::Arena* arena) const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const FrameMessage& from);
  void MergeFrom(const FrameMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  void DiscardUnknownFields();
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(FrameMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _arena_ptr_;
  }
  inline ::google::protobuf::Arena* MaybeArenaPtr() const {
    return _arena_ptr_;
  }
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // repeated .vehicle.VehicleInfo vehicles = 2;
  int vehicles_size() const;
  void clear_vehicles();
  static const int kVehiclesFieldNumber = 2;
  const ::vehicle::VehicleInfo& vehicles(int index) const;
  ::vehicle::VehicleInfo* mutable_vehicles(int index);
  ::vehicle::VehicleInfo* add_vehicles();
  ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleInfo >*
      mutable_vehicles();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleInfo >&
      vehicles() const;

  // repeated .vehicle.Nonmotor nonmotors = 3;
  int nonmotors_size() const;
  void clear_nonmotors();
  static const int kNonmotorsFieldNumber = 3;
  const ::vehicle::Nonmotor& nonmotors(int index) const;
  ::vehicle::Nonmotor* mutable_nonmotors(int index);
  ::vehicle::Nonmotor* add_nonmotors();
  ::google::protobuf::RepeatedPtrField< ::vehicle::Nonmotor >*
      mutable_nonmotors();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::Nonmotor >&
      nonmotors() const;

  // repeated .vehicle.Person persons = 4;
  int persons_size() const;
  void clear_persons();
  static const int kPersonsFieldNumber = 4;
  const ::vehicle::Person& persons(int index) const;
  ::vehicle::Person* mutable_persons(int index);
  ::vehicle::Person* add_persons();
  ::google::protobuf::RepeatedPtrField< ::vehicle::Person >*
      mutable_persons();
  const ::google::protobuf::RepeatedPtrField< ::vehicle::Person >&
      persons() const;

  // optional .vehicle.SmartMessage smart_msg = 5;
  bool has_smart_msg() const;
  void clear_smart_msg();
  static const int kSmartMsgFieldNumber = 5;
  const ::vehicle::SmartMessage& smart_msg() const;
  ::vehicle::SmartMessage* mutable_smart_msg();
  ::vehicle::SmartMessage* release_smart_msg();
  void set_allocated_smart_msg(::vehicle::SmartMessage* smart_msg);

  // @@protoc_insertion_point(class_scope:vehicle.FrameMessage)
 private:

  ::google::protobuf::internal::ArenaStringPtr _unknown_fields_;
  ::google::protobuf::Arena* _arena_ptr_;

  bool _is_default_instance_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleInfo > vehicles_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::Nonmotor > nonmotors_;
  ::google::protobuf::RepeatedPtrField< ::vehicle::Person > persons_;
  ::vehicle::SmartMessage* smart_msg_;
  mutable int _cached_size_;
  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_vehicle_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_vehicle_2eproto();
  #endif
  friend void protobuf_AssignDesc_vehicle_2eproto();
  friend void protobuf_ShutdownFile_vehicle_2eproto();

  void InitAsDefaultInstance();
  static FrameMessage* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Point

// optional float x = 1;
inline void Point::clear_x() {
  x_ = 0;
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:vehicle.Point.x)
  return x_;
}
inline void Point::set_x(float value) {

  x_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Point.x)
}

// optional float y = 2;
inline void Point::clear_y() {
  y_ = 0;
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:vehicle.Point.y)
  return y_;
}
inline void Point::set_y(float value) {

  y_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Point.y)
}

// optional float score = 3;
inline void Point::clear_score() {
  score_ = 0;
}
inline float Point::score() const {
  // @@protoc_insertion_point(field_get:vehicle.Point.score)
  return score_;
}
inline void Point::set_score(float value) {

  score_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Point.score)
}

// -------------------------------------------------------------------

// Points

// optional string type = 1;
inline void Points::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Points::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Points.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Points::set_type(const ::std::string& value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Points.type)
}
inline void Points::set_type(const char* value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Points.type)
}
inline void Points::set_type(const char* value, size_t size) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Points.type)
}
inline ::std::string* Points::mutable_type() {

  // @@protoc_insertion_point(field_mutable:vehicle.Points.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Points::release_type() {
  // @@protoc_insertion_point(field_release:vehicle.Points.type)

  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Points::set_allocated_type(::std::string* type) {
  if (type != NULL) {

  } else {

  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Points.type)
}

// repeated .vehicle.Point points = 2;
inline int Points::points_size() const {
  return points_.size();
}
inline void Points::clear_points() {
  points_.Clear();
}
inline const ::vehicle::Point& Points::points(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.Points.points)
  return points_.Get(index);
}
inline ::vehicle::Point* Points::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.Points.points)
  return points_.Mutable(index);
}
inline ::vehicle::Point* Points::add_points() {
  // @@protoc_insertion_point(field_add:vehicle.Points.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::Point >*
Points::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.Points.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::Point >&
Points::points() const {
  // @@protoc_insertion_point(field_list:vehicle.Points.points)
  return points_;
}

// -------------------------------------------------------------------

// Box

// optional string type = 1;
inline void Box::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Box::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Box::set_type(const ::std::string& value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Box.type)
}
inline void Box::set_type(const char* value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Box.type)
}
inline void Box::set_type(const char* value, size_t size) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Box.type)
}
inline ::std::string* Box::mutable_type() {

  // @@protoc_insertion_point(field_mutable:vehicle.Box.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Box::release_type() {
  // @@protoc_insertion_point(field_release:vehicle.Box.type)

  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Box::set_allocated_type(::std::string* type) {
  if (type != NULL) {

  } else {

  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Box.type)
}

// optional .vehicle.Point top_left = 2;
inline bool Box::has_top_left() const {
  return !_is_default_instance_ && top_left_ != NULL;
}
inline void Box::clear_top_left() {
  if (GetArenaNoVirtual() == NULL && top_left_ != NULL) delete top_left_;
  top_left_ = NULL;
}
inline const ::vehicle::Point& Box::top_left() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.top_left)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return top_left_ != NULL ? *top_left_ : *default_instance().top_left_;
#else
  return top_left_ != NULL ? *top_left_ : *default_instance_->top_left_;
#endif
}
inline ::vehicle::Point* Box::mutable_top_left() {

  if (top_left_ == NULL) {
    top_left_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Box.top_left)
  return top_left_;
}
inline ::vehicle::Point* Box::release_top_left() {
  // @@protoc_insertion_point(field_release:vehicle.Box.top_left)

  ::vehicle::Point* temp = top_left_;
  top_left_ = NULL;
  return temp;
}
inline void Box::set_allocated_top_left(::vehicle::Point* top_left) {
  delete top_left_;
  top_left_ = top_left;
  if (top_left) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Box.top_left)
}

// optional .vehicle.Point bottom_right = 3;
inline bool Box::has_bottom_right() const {
  return !_is_default_instance_ && bottom_right_ != NULL;
}
inline void Box::clear_bottom_right() {
  if (GetArenaNoVirtual() == NULL && bottom_right_ != NULL) delete bottom_right_;
  bottom_right_ = NULL;
}
inline const ::vehicle::Point& Box::bottom_right() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.bottom_right)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return bottom_right_ != NULL ? *bottom_right_ : *default_instance().bottom_right_;
#else
  return bottom_right_ != NULL ? *bottom_right_ : *default_instance_->bottom_right_;
#endif
}
inline ::vehicle::Point* Box::mutable_bottom_right() {

  if (bottom_right_ == NULL) {
    bottom_right_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Box.bottom_right)
  return bottom_right_;
}
inline ::vehicle::Point* Box::release_bottom_right() {
  // @@protoc_insertion_point(field_release:vehicle.Box.bottom_right)

  ::vehicle::Point* temp = bottom_right_;
  bottom_right_ = NULL;
  return temp;
}
inline void Box::set_allocated_bottom_right(::vehicle::Point* bottom_right) {
  delete bottom_right_;
  bottom_right_ = bottom_right;
  if (bottom_right) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Box.bottom_right)
}

// optional float score = 4;
inline void Box::clear_score() {
  score_ = 0;
}
inline float Box::score() const {
  // @@protoc_insertion_point(field_get:vehicle.Box.score)
  return score_;
}
inline void Box::set_score(float value) {

  score_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Box.score)
}

// -------------------------------------------------------------------

// Image

// optional bytes buf = 1;
inline void Image::clear_buf() {
  buf_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Image::buf() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.buf)
  return buf_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_buf(const ::std::string& value) {

  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Image.buf)
}
inline void Image::set_buf(const char* value) {

  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Image.buf)
}
inline void Image::set_buf(const void* value, size_t size) {

  buf_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Image.buf)
}
inline ::std::string* Image::mutable_buf() {

  // @@protoc_insertion_point(field_mutable:vehicle.Image.buf)
  return buf_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_buf() {
  // @@protoc_insertion_point(field_release:vehicle.Image.buf)

  return buf_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_buf(::std::string* buf) {
  if (buf != NULL) {

  } else {

  }
  buf_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), buf);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Image.buf)
}

// optional string type = 2;
inline void Image::clear_type() {
  type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Image::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.type)
  return type_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_type(const ::std::string& value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Image.type)
}
inline void Image::set_type(const char* value) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Image.type)
}
inline void Image::set_type(const char* value, size_t size) {

  type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Image.type)
}
inline ::std::string* Image::mutable_type() {

  // @@protoc_insertion_point(field_mutable:vehicle.Image.type)
  return type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Image::release_type() {
  // @@protoc_insertion_point(field_release:vehicle.Image.type)

  return type_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Image::set_allocated_type(::std::string* type) {
  if (type != NULL) {

  } else {

  }
  type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), type);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Image.type)
}

// optional uint32 width = 3;
inline void Image::clear_width() {
  width_ = 0u;
}
inline ::google::protobuf::uint32 Image::width() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.width)
  return width_;
}
inline void Image::set_width(::google::protobuf::uint32 value) {

  width_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Image.width)
}

// optional uint32 height = 4;
inline void Image::clear_height() {
  height_ = 0u;
}
inline ::google::protobuf::uint32 Image::height() const {
  // @@protoc_insertion_point(field_get:vehicle.Image.height)
  return height_;
}
inline void Image::set_height(::google::protobuf::uint32 value) {

  height_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Image.height)
}

// -------------------------------------------------------------------

// Plate

// optional .vehicle.Box box = 1;
inline bool Plate::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
inline void Plate::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
inline const ::vehicle::Box& Plate::box() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
inline ::vehicle::Box* Plate::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Plate.box)
  return box_;
}
inline ::vehicle::Box* Plate::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.Plate.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
inline void Plate::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Plate.box)
}

// optional bool is_double_plate = 2;
inline void Plate::clear_is_double_plate() {
  is_double_plate_ = false;
}
inline bool Plate::is_double_plate() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.is_double_plate)
  return is_double_plate_;
}
inline void Plate::set_is_double_plate(bool value) {

  is_double_plate_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Plate.is_double_plate)
}

// optional .vehicle.Points points = 3;
inline bool Plate::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
inline void Plate::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
inline const ::vehicle::Points& Plate::points() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
inline ::vehicle::Points* Plate::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Plate.points)
  return points_;
}
inline ::vehicle::Points* Plate::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.Plate.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
inline void Plate::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Plate.points)
}

// optional bytes plate_num = 4;
inline void Plate::clear_plate_num() {
  plate_num_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Plate::plate_num() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.plate_num)
  return plate_num_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Plate::set_plate_num(const ::std::string& value) {

  plate_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:vehicle.Plate.plate_num)
}
inline void Plate::set_plate_num(const char* value) {

  plate_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:vehicle.Plate.plate_num)
}
inline void Plate::set_plate_num(const void* value, size_t size) {

  plate_num_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:vehicle.Plate.plate_num)
}
inline ::std::string* Plate::mutable_plate_num() {

  // @@protoc_insertion_point(field_mutable:vehicle.Plate.plate_num)
  return plate_num_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Plate::release_plate_num() {
  // @@protoc_insertion_point(field_release:vehicle.Plate.plate_num)

  return plate_num_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Plate::set_allocated_plate_num(::std::string* plate_num) {
  if (plate_num != NULL) {

  } else {

  }
  plate_num_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), plate_num);
  // @@protoc_insertion_point(field_set_allocated:vehicle.Plate.plate_num)
}

// optional int32 color = 5;
inline void Plate::clear_color() {
  color_ = 0;
}
inline ::google::protobuf::int32 Plate::color() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.color)
  return color_;
}
inline void Plate::set_color(::google::protobuf::int32 value) {

  color_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Plate.color)
}

// optional int32 type = 6;
inline void Plate::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 Plate::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Plate.type)
  return type_;
}
inline void Plate::set_type(::google::protobuf::int32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Plate.type)
}

// -------------------------------------------------------------------

// Gis

// optional float longitude = 1;
inline void Gis::clear_longitude() {
  longitude_ = 0;
}
inline float Gis::longitude() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.longitude)
  return longitude_;
}
inline void Gis::set_longitude(float value) {

  longitude_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.longitude)
}

// optional float latitude = 2;
inline void Gis::clear_latitude() {
  latitude_ = 0;
}
inline float Gis::latitude() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.latitude)
  return latitude_;
}
inline void Gis::set_latitude(float value) {

  latitude_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.latitude)
}

// optional float width = 3;
inline void Gis::clear_width() {
  width_ = 0;
}
inline float Gis::width() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.width)
  return width_;
}
inline void Gis::set_width(float value) {

  width_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.width)
}

// optional float height = 4;
inline void Gis::clear_height() {
  height_ = 0;
}
inline float Gis::height() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.height)
  return height_;
}
inline void Gis::set_height(float value) {

  height_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.height)
}

// optional float orientation = 5;
inline void Gis::clear_orientation() {
  orientation_ = 0;
}
inline float Gis::orientation() const {
  // @@protoc_insertion_point(field_get:vehicle.Gis.orientation)
  return orientation_;
}
inline void Gis::set_orientation(float value) {

  orientation_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Gis.orientation)
}

// -------------------------------------------------------------------

// VehicleInfo

// optional uint64 track_id = 1;
inline void VehicleInfo::clear_track_id() {
  track_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 VehicleInfo::track_id() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.track_id)
  return track_id_;
}
inline void VehicleInfo::set_track_id(::google::protobuf::uint64 value) {

  track_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.track_id)
}

// optional int32 type = 2;
inline void VehicleInfo::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::type() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.type)
  return type_;
}
inline void VehicleInfo::set_type(::google::protobuf::int32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.type)
}

// optional int32 color = 3;
inline void VehicleInfo::clear_color() {
  color_ = 0;
}
inline ::google::protobuf::int32 VehicleInfo::color() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.color)
  return color_;
}
inline void VehicleInfo::set_color(::google::protobuf::int32 value) {

  color_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.color)
}

// optional .vehicle.Box box = 4;
inline bool VehicleInfo::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
inline void VehicleInfo::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
inline const ::vehicle::Box& VehicleInfo::box() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
inline ::vehicle::Box* VehicleInfo::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.box)
  return box_;
}
inline ::vehicle::Box* VehicleInfo::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.box)
}

// optional .vehicle.Points points = 5;
inline bool VehicleInfo::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
inline void VehicleInfo::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
inline const ::vehicle::Points& VehicleInfo::points() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
inline ::vehicle::Points* VehicleInfo::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.points)
  return points_;
}
inline ::vehicle::Points* VehicleInfo::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.points)
}

// optional .vehicle.Plate plate_info = 6;
inline bool VehicleInfo::has_plate_info() const {
  return !_is_default_instance_ && plate_info_ != NULL;
}
inline void VehicleInfo::clear_plate_info() {
  if (GetArenaNoVirtual() == NULL && plate_info_ != NULL) delete plate_info_;
  plate_info_ = NULL;
}
inline const ::vehicle::Plate& VehicleInfo::plate_info() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.plate_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return plate_info_ != NULL ? *plate_info_ : *default_instance().plate_info_;
#else
  return plate_info_ != NULL ? *plate_info_ : *default_instance_->plate_info_;
#endif
}
inline ::vehicle::Plate* VehicleInfo::mutable_plate_info() {

  if (plate_info_ == NULL) {
    plate_info_ = new ::vehicle::Plate;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.plate_info)
  return plate_info_;
}
inline ::vehicle::Plate* VehicleInfo::release_plate_info() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.plate_info)

  ::vehicle::Plate* temp = plate_info_;
  plate_info_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_plate_info(::vehicle::Plate* plate_info) {
  delete plate_info_;
  plate_info_ = plate_info;
  if (plate_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.plate_info)
}

// optional .vehicle.Point location = 7;
inline bool VehicleInfo::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void VehicleInfo::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::vehicle::Point& VehicleInfo::location() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
inline ::vehicle::Point* VehicleInfo::mutable_location() {

  if (location_ == NULL) {
    location_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.location)
  return location_;
}
inline ::vehicle::Point* VehicleInfo::release_location() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.location)

  ::vehicle::Point* temp = location_;
  location_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_location(::vehicle::Point* location) {
  delete location_;
  location_ = location;
  if (location) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.location)
}

// optional uint32 lane_id = 8;
inline void VehicleInfo::clear_lane_id() {
  lane_id_ = 0u;
}
inline ::google::protobuf::uint32 VehicleInfo::lane_id() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.lane_id)
  return lane_id_;
}
inline void VehicleInfo::set_lane_id(::google::protobuf::uint32 value) {

  lane_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.lane_id)
}

// optional float speed = 9;
inline void VehicleInfo::clear_speed() {
  speed_ = 0;
}
inline float VehicleInfo::speed() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.speed)
  return speed_;
}
inline void VehicleInfo::set_speed(float value) {

  speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleInfo.speed)
}

// optional .vehicle.Gis gis_info = 10;
inline bool VehicleInfo::has_gis_info() const {
  return !_is_default_instance_ && gis_info_ != NULL;
}
inline void VehicleInfo::clear_gis_info() {
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;
}
inline const ::vehicle::Gis& VehicleInfo::gis_info() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleInfo.gis_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gis_info_ != NULL ? *gis_info_ : *default_instance().gis_info_;
#else
  return gis_info_ != NULL ? *gis_info_ : *default_instance_->gis_info_;
#endif
}
inline ::vehicle::Gis* VehicleInfo::mutable_gis_info() {

  if (gis_info_ == NULL) {
    gis_info_ = new ::vehicle::Gis;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleInfo.gis_info)
  return gis_info_;
}
inline ::vehicle::Gis* VehicleInfo::release_gis_info() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleInfo.gis_info)

  ::vehicle::Gis* temp = gis_info_;
  gis_info_ = NULL;
  return temp;
}
inline void VehicleInfo::set_allocated_gis_info(::vehicle::Gis* gis_info) {
  delete gis_info_;
  gis_info_ = gis_info;
  if (gis_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleInfo.gis_info)
}

// -------------------------------------------------------------------

// Nonmotor

// optional uint64 track_id = 1;
inline void Nonmotor::clear_track_id() {
  track_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Nonmotor::track_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.track_id)
  return track_id_;
}
inline void Nonmotor::set_track_id(::google::protobuf::uint64 value) {

  track_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Nonmotor.track_id)
}

// optional .vehicle.Box box = 2;
inline bool Nonmotor::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
inline void Nonmotor::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
inline const ::vehicle::Box& Nonmotor::box() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
inline ::vehicle::Box* Nonmotor::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.box)
  return box_;
}
inline ::vehicle::Box* Nonmotor::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
inline void Nonmotor::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.box)
}

// optional .vehicle.Points points = 3;
inline bool Nonmotor::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
inline void Nonmotor::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
inline const ::vehicle::Points& Nonmotor::points() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
inline ::vehicle::Points* Nonmotor::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.points)
  return points_;
}
inline ::vehicle::Points* Nonmotor::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
inline void Nonmotor::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.points)
}

// optional .vehicle.Point location = 4;
inline bool Nonmotor::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void Nonmotor::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::vehicle::Point& Nonmotor::location() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
inline ::vehicle::Point* Nonmotor::mutable_location() {

  if (location_ == NULL) {
    location_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.location)
  return location_;
}
inline ::vehicle::Point* Nonmotor::release_location() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.location)

  ::vehicle::Point* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Nonmotor::set_allocated_location(::vehicle::Point* location) {
  delete location_;
  location_ = location;
  if (location) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.location)
}

// optional uint32 lane_id = 5;
inline void Nonmotor::clear_lane_id() {
  lane_id_ = 0u;
}
inline ::google::protobuf::uint32 Nonmotor::lane_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.lane_id)
  return lane_id_;
}
inline void Nonmotor::set_lane_id(::google::protobuf::uint32 value) {

  lane_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Nonmotor.lane_id)
}

// optional float speed = 6;
inline void Nonmotor::clear_speed() {
  speed_ = 0;
}
inline float Nonmotor::speed() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.speed)
  return speed_;
}
inline void Nonmotor::set_speed(float value) {

  speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Nonmotor.speed)
}

// optional .vehicle.Gis gis_info = 7;
inline bool Nonmotor::has_gis_info() const {
  return !_is_default_instance_ && gis_info_ != NULL;
}
inline void Nonmotor::clear_gis_info() {
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;
}
inline const ::vehicle::Gis& Nonmotor::gis_info() const {
  // @@protoc_insertion_point(field_get:vehicle.Nonmotor.gis_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gis_info_ != NULL ? *gis_info_ : *default_instance().gis_info_;
#else
  return gis_info_ != NULL ? *gis_info_ : *default_instance_->gis_info_;
#endif
}
inline ::vehicle::Gis* Nonmotor::mutable_gis_info() {

  if (gis_info_ == NULL) {
    gis_info_ = new ::vehicle::Gis;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Nonmotor.gis_info)
  return gis_info_;
}
inline ::vehicle::Gis* Nonmotor::release_gis_info() {
  // @@protoc_insertion_point(field_release:vehicle.Nonmotor.gis_info)

  ::vehicle::Gis* temp = gis_info_;
  gis_info_ = NULL;
  return temp;
}
inline void Nonmotor::set_allocated_gis_info(::vehicle::Gis* gis_info) {
  delete gis_info_;
  gis_info_ = gis_info;
  if (gis_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Nonmotor.gis_info)
}

// -------------------------------------------------------------------

// Person

// optional uint64 track_id = 1;
inline void Person::clear_track_id() {
  track_id_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Person::track_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.track_id)
  return track_id_;
}
inline void Person::set_track_id(::google::protobuf::uint64 value) {

  track_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Person.track_id)
}

// optional .vehicle.Box box = 2;
inline bool Person::has_box() const {
  return !_is_default_instance_ && box_ != NULL;
}
inline void Person::clear_box() {
  if (GetArenaNoVirtual() == NULL && box_ != NULL) delete box_;
  box_ = NULL;
}
inline const ::vehicle::Box& Person::box() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.box)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return box_ != NULL ? *box_ : *default_instance().box_;
#else
  return box_ != NULL ? *box_ : *default_instance_->box_;
#endif
}
inline ::vehicle::Box* Person::mutable_box() {

  if (box_ == NULL) {
    box_ = new ::vehicle::Box;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.box)
  return box_;
}
inline ::vehicle::Box* Person::release_box() {
  // @@protoc_insertion_point(field_release:vehicle.Person.box)

  ::vehicle::Box* temp = box_;
  box_ = NULL;
  return temp;
}
inline void Person::set_allocated_box(::vehicle::Box* box) {
  delete box_;
  box_ = box;
  if (box) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.box)
}

// optional .vehicle.Points points = 3;
inline bool Person::has_points() const {
  return !_is_default_instance_ && points_ != NULL;
}
inline void Person::clear_points() {
  if (GetArenaNoVirtual() == NULL && points_ != NULL) delete points_;
  points_ = NULL;
}
inline const ::vehicle::Points& Person::points() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.points)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return points_ != NULL ? *points_ : *default_instance().points_;
#else
  return points_ != NULL ? *points_ : *default_instance_->points_;
#endif
}
inline ::vehicle::Points* Person::mutable_points() {

  if (points_ == NULL) {
    points_ = new ::vehicle::Points;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.points)
  return points_;
}
inline ::vehicle::Points* Person::release_points() {
  // @@protoc_insertion_point(field_release:vehicle.Person.points)

  ::vehicle::Points* temp = points_;
  points_ = NULL;
  return temp;
}
inline void Person::set_allocated_points(::vehicle::Points* points) {
  delete points_;
  points_ = points;
  if (points) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.points)
}

// optional .vehicle.Point location = 4;
inline bool Person::has_location() const {
  return !_is_default_instance_ && location_ != NULL;
}
inline void Person::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) delete location_;
  location_ = NULL;
}
inline const ::vehicle::Point& Person::location() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.location)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return location_ != NULL ? *location_ : *default_instance().location_;
#else
  return location_ != NULL ? *location_ : *default_instance_->location_;
#endif
}
inline ::vehicle::Point* Person::mutable_location() {

  if (location_ == NULL) {
    location_ = new ::vehicle::Point;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.location)
  return location_;
}
inline ::vehicle::Point* Person::release_location() {
  // @@protoc_insertion_point(field_release:vehicle.Person.location)

  ::vehicle::Point* temp = location_;
  location_ = NULL;
  return temp;
}
inline void Person::set_allocated_location(::vehicle::Point* location) {
  delete location_;
  location_ = location;
  if (location) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.location)
}

// optional uint32 lane_id = 5;
inline void Person::clear_lane_id() {
  lane_id_ = 0u;
}
inline ::google::protobuf::uint32 Person::lane_id() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.lane_id)
  return lane_id_;
}
inline void Person::set_lane_id(::google::protobuf::uint32 value) {

  lane_id_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Person.lane_id)
}

// optional float speed = 6;
inline void Person::clear_speed() {
  speed_ = 0;
}
inline float Person::speed() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.speed)
  return speed_;
}
inline void Person::set_speed(float value) {

  speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Person.speed)
}

// optional .vehicle.Gis gis_info = 7;
inline bool Person::has_gis_info() const {
  return !_is_default_instance_ && gis_info_ != NULL;
}
inline void Person::clear_gis_info() {
  if (GetArenaNoVirtual() == NULL && gis_info_ != NULL) delete gis_info_;
  gis_info_ = NULL;
}
inline const ::vehicle::Gis& Person::gis_info() const {
  // @@protoc_insertion_point(field_get:vehicle.Person.gis_info)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return gis_info_ != NULL ? *gis_info_ : *default_instance().gis_info_;
#else
  return gis_info_ != NULL ? *gis_info_ : *default_instance_->gis_info_;
#endif
}
inline ::vehicle::Gis* Person::mutable_gis_info() {

  if (gis_info_ == NULL) {
    gis_info_ = new ::vehicle::Gis;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.Person.gis_info)
  return gis_info_;
}
inline ::vehicle::Gis* Person::release_gis_info() {
  // @@protoc_insertion_point(field_release:vehicle.Person.gis_info)

  ::vehicle::Gis* temp = gis_info_;
  gis_info_ = NULL;
  return temp;
}
inline void Person::set_allocated_gis_info(::vehicle::Gis* gis_info) {
  delete gis_info_;
  gis_info_ = gis_info;
  if (gis_info) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.Person.gis_info)
}

// -------------------------------------------------------------------

// TrafficCondition

// optional fixed64 timestamp = 1;
inline void TrafficCondition::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 TrafficCondition::timestamp() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficCondition.timestamp)
  return timestamp_;
}
inline void TrafficCondition::set_timestamp(::google::protobuf::uint64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficCondition.timestamp)
}

// optional uint32 type = 2;
inline void TrafficCondition::clear_type() {
  type_ = 0u;
}
inline ::google::protobuf::uint32 TrafficCondition::type() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficCondition.type)
  return type_;
}
inline void TrafficCondition::set_type(::google::protobuf::uint32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficCondition.type)
}

// optional float value = 3;
inline void TrafficCondition::clear_value() {
  value_ = 0;
}
inline float TrafficCondition::value() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficCondition.value)
  return value_;
}
inline void TrafficCondition::set_value(float value) {

  value_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficCondition.value)
}

// -------------------------------------------------------------------

// TrafficFlow

// optional uint32 hour_index = 1;
inline void TrafficFlow::clear_hour_index() {
  hour_index_ = 0u;
}
inline ::google::protobuf::uint32 TrafficFlow::hour_index() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.hour_index)
  return hour_index_;
}
inline void TrafficFlow::set_hour_index(::google::protobuf::uint32 value) {

  hour_index_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.hour_index)
}

// optional uint32 cycle_count = 2;
inline void TrafficFlow::clear_cycle_count() {
  cycle_count_ = 0u;
}
inline ::google::protobuf::uint32 TrafficFlow::cycle_count() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.cycle_count)
  return cycle_count_;
}
inline void TrafficFlow::set_cycle_count(::google::protobuf::uint32 value) {

  cycle_count_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.cycle_count)
}

// optional uint32 cycle_minute = 3;
inline void TrafficFlow::clear_cycle_minute() {
  cycle_minute_ = 0u;
}
inline ::google::protobuf::uint32 TrafficFlow::cycle_minute() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.cycle_minute)
  return cycle_minute_;
}
inline void TrafficFlow::set_cycle_minute(::google::protobuf::uint32 value) {

  cycle_minute_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.cycle_minute)
}

// optional uint32 vehicle_sum = 4;
inline void TrafficFlow::clear_vehicle_sum() {
  vehicle_sum_ = 0u;
}
inline ::google::protobuf::uint32 TrafficFlow::vehicle_sum() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.vehicle_sum)
  return vehicle_sum_;
}
inline void TrafficFlow::set_vehicle_sum(::google::protobuf::uint32 value) {

  vehicle_sum_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.vehicle_sum)
}

// optional uint32 big_vehicle_sum = 5;
inline void TrafficFlow::clear_big_vehicle_sum() {
  big_vehicle_sum_ = 0u;
}
inline ::google::protobuf::uint32 TrafficFlow::big_vehicle_sum() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.big_vehicle_sum)
  return big_vehicle_sum_;
}
inline void TrafficFlow::set_big_vehicle_sum(::google::protobuf::uint32 value) {

  big_vehicle_sum_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.big_vehicle_sum)
}

// optional uint32 small_vehicle_sum = 6;
inline void TrafficFlow::clear_small_vehicle_sum() {
  small_vehicle_sum_ = 0u;
}
inline ::google::protobuf::uint32 TrafficFlow::small_vehicle_sum() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.small_vehicle_sum)
  return small_vehicle_sum_;
}
inline void TrafficFlow::set_small_vehicle_sum(::google::protobuf::uint32 value) {

  small_vehicle_sum_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.small_vehicle_sum)
}

// optional float mean_speed = 7;
inline void TrafficFlow::clear_mean_speed() {
  mean_speed_ = 0;
}
inline float TrafficFlow::mean_speed() const {
  // @@protoc_insertion_point(field_get:vehicle.TrafficFlow.mean_speed)
  return mean_speed_;
}
inline void TrafficFlow::set_mean_speed(float value) {

  mean_speed_ = value;
  // @@protoc_insertion_point(field_set:vehicle.TrafficFlow.mean_speed)
}

// -------------------------------------------------------------------

// Anomaly

// optional int32 type = 1;
inline void Anomaly::clear_type() {
  type_ = 0;
}
inline ::google::protobuf::int32 Anomaly::type() const {
  // @@protoc_insertion_point(field_get:vehicle.Anomaly.type)
  return type_;
}
inline void Anomaly::set_type(::google::protobuf::int32 value) {

  type_ = value;
  // @@protoc_insertion_point(field_set:vehicle.Anomaly.type)
}

// repeated .vehicle.VehicleCapture vehicle_captures = 2;
inline int Anomaly::vehicle_captures_size() const {
  return vehicle_captures_.size();
}
inline void Anomaly::clear_vehicle_captures() {
  vehicle_captures_.Clear();
}
inline const ::vehicle::VehicleCapture& Anomaly::vehicle_captures(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_.Get(index);
}
inline ::vehicle::VehicleCapture* Anomaly::mutable_vehicle_captures(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_.Mutable(index);
}
inline ::vehicle::VehicleCapture* Anomaly::add_vehicle_captures() {
  // @@protoc_insertion_point(field_add:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >*
Anomaly::mutable_vehicle_captures() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.Anomaly.vehicle_captures)
  return &vehicle_captures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >&
Anomaly::vehicle_captures() const {
  // @@protoc_insertion_point(field_list:vehicle.Anomaly.vehicle_captures)
  return vehicle_captures_;
}

// -------------------------------------------------------------------

// VehicleCapture

// optional fixed64 timestamp = 1;
inline void VehicleCapture::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 VehicleCapture::timestamp() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleCapture.timestamp)
  return timestamp_;
}
inline void VehicleCapture::set_timestamp(::google::protobuf::uint64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vehicle.VehicleCapture.timestamp)
}

// optional .vehicle.VehicleInfo vehicle = 2;
inline bool VehicleCapture::has_vehicle() const {
  return !_is_default_instance_ && vehicle_ != NULL;
}
inline void VehicleCapture::clear_vehicle() {
  if (GetArenaNoVirtual() == NULL && vehicle_ != NULL) delete vehicle_;
  vehicle_ = NULL;
}
inline const ::vehicle::VehicleInfo& VehicleCapture::vehicle() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleCapture.vehicle)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return vehicle_ != NULL ? *vehicle_ : *default_instance().vehicle_;
#else
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
#endif
}
inline ::vehicle::VehicleInfo* VehicleCapture::mutable_vehicle() {

  if (vehicle_ == NULL) {
    vehicle_ = new ::vehicle::VehicleInfo;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleCapture.vehicle)
  return vehicle_;
}
inline ::vehicle::VehicleInfo* VehicleCapture::release_vehicle() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleCapture.vehicle)

  ::vehicle::VehicleInfo* temp = vehicle_;
  vehicle_ = NULL;
  return temp;
}
inline void VehicleCapture::set_allocated_vehicle(::vehicle::VehicleInfo* vehicle) {
  delete vehicle_;
  vehicle_ = vehicle;
  if (vehicle) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleCapture.vehicle)
}

// optional .vehicle.Image image = 3;
inline bool VehicleCapture::has_image() const {
  return !_is_default_instance_ && image_ != NULL;
}
inline void VehicleCapture::clear_image() {
  if (GetArenaNoVirtual() == NULL && image_ != NULL) delete image_;
  image_ = NULL;
}
inline const ::vehicle::Image& VehicleCapture::image() const {
  // @@protoc_insertion_point(field_get:vehicle.VehicleCapture.image)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return image_ != NULL ? *image_ : *default_instance().image_;
#else
  return image_ != NULL ? *image_ : *default_instance_->image_;
#endif
}
inline ::vehicle::Image* VehicleCapture::mutable_image() {

  if (image_ == NULL) {
    image_ = new ::vehicle::Image;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.VehicleCapture.image)
  return image_;
}
inline ::vehicle::Image* VehicleCapture::release_image() {
  // @@protoc_insertion_point(field_release:vehicle.VehicleCapture.image)

  ::vehicle::Image* temp = image_;
  image_ = NULL;
  return temp;
}
inline void VehicleCapture::set_allocated_image(::vehicle::Image* image) {
  delete image_;
  image_ = image;
  if (image) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.VehicleCapture.image)
}

// -------------------------------------------------------------------

// SmartMessage

// repeated .vehicle.Anomaly anomalys = 1;
inline int SmartMessage::anomalys_size() const {
  return anomalys_.size();
}
inline void SmartMessage::clear_anomalys() {
  anomalys_.Clear();
}
inline const ::vehicle::Anomaly& SmartMessage::anomalys(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.anomalys)
  return anomalys_.Get(index);
}
inline ::vehicle::Anomaly* SmartMessage::mutable_anomalys(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.anomalys)
  return anomalys_.Mutable(index);
}
inline ::vehicle::Anomaly* SmartMessage::add_anomalys() {
  // @@protoc_insertion_point(field_add:vehicle.SmartMessage.anomalys)
  return anomalys_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::Anomaly >*
SmartMessage::mutable_anomalys() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.SmartMessage.anomalys)
  return &anomalys_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::Anomaly >&
SmartMessage::anomalys() const {
  // @@protoc_insertion_point(field_list:vehicle.SmartMessage.anomalys)
  return anomalys_;
}

// repeated .vehicle.VehicleCapture captures = 2;
inline int SmartMessage::captures_size() const {
  return captures_.size();
}
inline void SmartMessage::clear_captures() {
  captures_.Clear();
}
inline const ::vehicle::VehicleCapture& SmartMessage::captures(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.captures)
  return captures_.Get(index);
}
inline ::vehicle::VehicleCapture* SmartMessage::mutable_captures(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.captures)
  return captures_.Mutable(index);
}
inline ::vehicle::VehicleCapture* SmartMessage::add_captures() {
  // @@protoc_insertion_point(field_add:vehicle.SmartMessage.captures)
  return captures_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >*
SmartMessage::mutable_captures() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.SmartMessage.captures)
  return &captures_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleCapture >&
SmartMessage::captures() const {
  // @@protoc_insertion_point(field_list:vehicle.SmartMessage.captures)
  return captures_;
}

// repeated .vehicle.TrafficCondition traffic_conditions = 3;
inline int SmartMessage::traffic_conditions_size() const {
  return traffic_conditions_.size();
}
inline void SmartMessage::clear_traffic_conditions() {
  traffic_conditions_.Clear();
}
inline const ::vehicle::TrafficCondition& SmartMessage::traffic_conditions(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_.Get(index);
}
inline ::vehicle::TrafficCondition* SmartMessage::mutable_traffic_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_.Mutable(index);
}
inline ::vehicle::TrafficCondition* SmartMessage::add_traffic_conditions() {
  // @@protoc_insertion_point(field_add:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::TrafficCondition >*
SmartMessage::mutable_traffic_conditions() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.SmartMessage.traffic_conditions)
  return &traffic_conditions_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::TrafficCondition >&
SmartMessage::traffic_conditions() const {
  // @@protoc_insertion_point(field_list:vehicle.SmartMessage.traffic_conditions)
  return traffic_conditions_;
}

// optional .vehicle.TrafficFlow traffic_flow = 4;
inline bool SmartMessage::has_traffic_flow() const {
  return !_is_default_instance_ && traffic_flow_ != NULL;
}
inline void SmartMessage::clear_traffic_flow() {
  if (GetArenaNoVirtual() == NULL && traffic_flow_ != NULL) delete traffic_flow_;
  traffic_flow_ = NULL;
}
inline const ::vehicle::TrafficFlow& SmartMessage::traffic_flow() const {
  // @@protoc_insertion_point(field_get:vehicle.SmartMessage.traffic_flow)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return traffic_flow_ != NULL ? *traffic_flow_ : *default_instance().traffic_flow_;
#else
  return traffic_flow_ != NULL ? *traffic_flow_ : *default_instance_->traffic_flow_;
#endif
}
inline ::vehicle::TrafficFlow* SmartMessage::mutable_traffic_flow() {

  if (traffic_flow_ == NULL) {
    traffic_flow_ = new ::vehicle::TrafficFlow;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.SmartMessage.traffic_flow)
  return traffic_flow_;
}
inline ::vehicle::TrafficFlow* SmartMessage::release_traffic_flow() {
  // @@protoc_insertion_point(field_release:vehicle.SmartMessage.traffic_flow)

  ::vehicle::TrafficFlow* temp = traffic_flow_;
  traffic_flow_ = NULL;
  return temp;
}
inline void SmartMessage::set_allocated_traffic_flow(::vehicle::TrafficFlow* traffic_flow) {
  delete traffic_flow_;
  traffic_flow_ = traffic_flow;
  if (traffic_flow) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.SmartMessage.traffic_flow)
}

// -------------------------------------------------------------------

// FrameMessage

// optional fixed64 timestamp = 1;
inline void FrameMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 FrameMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.timestamp)
  return timestamp_;
}
inline void FrameMessage::set_timestamp(::google::protobuf::uint64 value) {

  timestamp_ = value;
  // @@protoc_insertion_point(field_set:vehicle.FrameMessage.timestamp)
}

// repeated .vehicle.VehicleInfo vehicles = 2;
inline int FrameMessage::vehicles_size() const {
  return vehicles_.size();
}
inline void FrameMessage::clear_vehicles() {
  vehicles_.Clear();
}
inline const ::vehicle::VehicleInfo& FrameMessage::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.vehicles)
  return vehicles_.Get(index);
}
inline ::vehicle::VehicleInfo* FrameMessage::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.vehicles)
  return vehicles_.Mutable(index);
}
inline ::vehicle::VehicleInfo* FrameMessage::add_vehicles() {
  // @@protoc_insertion_point(field_add:vehicle.FrameMessage.vehicles)
  return vehicles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleInfo >*
FrameMessage::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.FrameMessage.vehicles)
  return &vehicles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::VehicleInfo >&
FrameMessage::vehicles() const {
  // @@protoc_insertion_point(field_list:vehicle.FrameMessage.vehicles)
  return vehicles_;
}

// repeated .vehicle.Nonmotor nonmotors = 3;
inline int FrameMessage::nonmotors_size() const {
  return nonmotors_.size();
}
inline void FrameMessage::clear_nonmotors() {
  nonmotors_.Clear();
}
inline const ::vehicle::Nonmotor& FrameMessage::nonmotors(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.nonmotors)
  return nonmotors_.Get(index);
}
inline ::vehicle::Nonmotor* FrameMessage::mutable_nonmotors(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.nonmotors)
  return nonmotors_.Mutable(index);
}
inline ::vehicle::Nonmotor* FrameMessage::add_nonmotors() {
  // @@protoc_insertion_point(field_add:vehicle.FrameMessage.nonmotors)
  return nonmotors_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::Nonmotor >*
FrameMessage::mutable_nonmotors() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.FrameMessage.nonmotors)
  return &nonmotors_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::Nonmotor >&
FrameMessage::nonmotors() const {
  // @@protoc_insertion_point(field_list:vehicle.FrameMessage.nonmotors)
  return nonmotors_;
}

// repeated .vehicle.Person persons = 4;
inline int FrameMessage::persons_size() const {
  return persons_.size();
}
inline void FrameMessage::clear_persons() {
  persons_.Clear();
}
inline const ::vehicle::Person& FrameMessage::persons(int index) const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.persons)
  return persons_.Get(index);
}
inline ::vehicle::Person* FrameMessage::mutable_persons(int index) {
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.persons)
  return persons_.Mutable(index);
}
inline ::vehicle::Person* FrameMessage::add_persons() {
  // @@protoc_insertion_point(field_add:vehicle.FrameMessage.persons)
  return persons_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::vehicle::Person >*
FrameMessage::mutable_persons() {
  // @@protoc_insertion_point(field_mutable_list:vehicle.FrameMessage.persons)
  return &persons_;
}
inline const ::google::protobuf::RepeatedPtrField< ::vehicle::Person >&
FrameMessage::persons() const {
  // @@protoc_insertion_point(field_list:vehicle.FrameMessage.persons)
  return persons_;
}

// optional .vehicle.SmartMessage smart_msg = 5;
inline bool FrameMessage::has_smart_msg() const {
  return !_is_default_instance_ && smart_msg_ != NULL;
}
inline void FrameMessage::clear_smart_msg() {
  if (GetArenaNoVirtual() == NULL && smart_msg_ != NULL) delete smart_msg_;
  smart_msg_ = NULL;
}
inline const ::vehicle::SmartMessage& FrameMessage::smart_msg() const {
  // @@protoc_insertion_point(field_get:vehicle.FrameMessage.smart_msg)
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return smart_msg_ != NULL ? *smart_msg_ : *default_instance().smart_msg_;
#else
  return smart_msg_ != NULL ? *smart_msg_ : *default_instance_->smart_msg_;
#endif
}
inline ::vehicle::SmartMessage* FrameMessage::mutable_smart_msg() {

  if (smart_msg_ == NULL) {
    smart_msg_ = new ::vehicle::SmartMessage;
  }
  // @@protoc_insertion_point(field_mutable:vehicle.FrameMessage.smart_msg)
  return smart_msg_;
}
inline ::vehicle::SmartMessage* FrameMessage::release_smart_msg() {
  // @@protoc_insertion_point(field_release:vehicle.FrameMessage.smart_msg)

  ::vehicle::SmartMessage* temp = smart_msg_;
  smart_msg_ = NULL;
  return temp;
}
inline void FrameMessage::set_allocated_smart_msg(::vehicle::SmartMessage* smart_msg) {
  delete smart_msg_;
  smart_msg_ = smart_msg;
  if (smart_msg) {

  } else {

  }
  // @@protoc_insertion_point(field_set_allocated:vehicle.FrameMessage.smart_msg)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace vehicle

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_vehicle_2eproto__INCLUDED
